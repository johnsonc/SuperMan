# Project-Manager mode
* Header 							   :noexport:
:PROPERTIES:
#+TITLE: An emacs-org project manager for applied statisticians
#+EMAIL: tag@biostat.ku.dk
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc author:nil
#+LaTeX_HEADER:\usepackage{authblk}
#+LaTeX_HEADER:\usepackage{natbib}
#+LaTeX_HEADER:\usepackage[T1]{fontenc}
#+LaTeX_HEADER:\renewcommand*\familydefault{\sfdefault}
#+LaTeX_HEADER:\usepackage[table,usenames,dvipsnames]{xcolor}
#+LaTeX_HEADER:\definecolor{lightGray}{gray}{0.98}
#+LaTeX_HEADER:\definecolor{medioGray}{gray}{0.83}
#+LaTeX_HEADER:\rowcolors{1}{medioGray}{lightGray}
#+LaTeX_HEADER:\usepackage{attachfile}
#+LaTeX_HEADER:\usepackage{array}
#+LaTeX_HEADER:\author{Thomas Alexander Gerds}
#+LaTeX_HEADER:\affil{Department of Biostatistics, University of Copenhagen, Denmark}
#+LaTeX_HEADER:\author{Klaus K\"ahler Holst}
#+LaTeX_HEADER:\affil{Department of Biostatistics, University of Copenhagen, Denmark}
#+LaTeX_HEADER:\author{Jochen Knaus}
#+LaTeX_HEADER:\affil{Department of Medical Biometrie and Medical Informatics, University of Freiburg, Freiburg, Germany}
#+LaTeX_HEADER:\newcommand{\sfootnote}[1]{\renewcommand{\thefootnote}{\fnsymbol{footnote}}\footnote{#1}\setcounter{footnote}{0}\renewcommand{\thefootnote}{\arabic{foot note}}}
#+LaTeX_HEADER:\makeatletter\def\blfootnote{\xdef\@thefnmark{}\@footnotetext}\makeatother
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LaTeX_HEADER \itemsep2pt
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)
#+LaTeX_HEADER: \usepackage{color}
#+LATEX_HEADER: \lstset{
#+LATEX_HEADER: keywordstyle=\color{blue},
#+LATEX_HEADER: commentstyle=\color{red},
#+LATEX_HEADER: stringstyle=\color[rgb]{0,.5,0},
#+LATEX_HEADER: basicstyle=\ttfamily\small,
#+LATEX_HEADER: columns=fullflexible,
#+LATEX_HEADER: breaklines=true,        % sets automatic line breaking
#+LATEX_HEADER: breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
#+LATEX_HEADER: numbers=left,
#+LATEX_HEADER: numberstyle=\ttfamily\tiny\color{gray},
#+LATEX_HEADER: stepnumber=1,
#+LATEX_HEADER: numbersep=10pt,
#+LATEX_HEADER: backgroundcolor=\color{white},
#+LATEX_HEADER: tabsize=4,
#+LATEX_HEADER: showspaces=false,
#+LATEX_HEADER: showstringspaces=false,
#+LATEX_HEADER: xleftmargin=.23in,
#+LATEX_HEADER: frame=single,
#+LATEX_HEADER: basewidth={0.5em,0.4em}
#+LATEX_HEADER: }
#+PROPERTY: session *R* 
#+PROPERTY: cache yes
#+PROPERTY: tangle yes
#+PROPERTY: colnames yes
:END:
  
* Introduction 
  
  This document simulaneously describes and defines a project manager
  for applied statistical workflows based on the fabulous and popular
  emacs =org-mode=. Really it describes and automates one out of many
  possibilities to customize =org-mode=.
  
** Getting started
   
   The first thing to do is to define some new projects. Obviously,
   you would rather read in your existing projects. Don't worry, 
   this is also possible and explained below.
   
*** The project manager file
    
    
#+BEGIN_SRC emacs-lisp :exports none :eval never :tangle no
  (setq org-pro-file "~/projects/manager.org")
  (find-file org-pro-file)
#+END_SRC

**** What is a project?
    
     As in real life, a project can be many different things. The
     prototype project consists of a /location/, that is a directory
     on your computer, and an index file. (Actually, only one of
     /index/ and /location/ is required.)
     
**** How to define a project?
     
     Projects are defined in the file /org-pro-file/
     (yes-you-need-to-create-this-file) in the following format.
     
#+BEGIN_SRC org :tangle no
 * Cat 1
 ** Subcat 1
 *** Subsubcat 1
 **** Learning org (My first org-pro project)
 :PROPERTIES:
 :NICKNAME: howto-org
 :INDEX:  ~/knowhow/howto.org
 :LOCATION: ~/knowhow/
 :OTHERS: justme
 :END:     
 **** Test org-pro
 :PROPERTIES:
 :NICKNAME: howto-org
 :INDEX:  ~/knowhow/howto.org
 :LOCATION: ~/knowhow/
 :OTHERS: Alphonse Quack
 :END:     
#+END_SRC

** Git support
*** Requirements

You need to install the program git.

*** Git hub

To do push changes to a github repository it is useful to set up git  
https://help.github.com/articles/set-up-git
and to be free of typing the username and password when doing "git push".

If you use the SSH repo URL instead, SSH keys are used for
authentication. This guide offers help generating and using an SSH key
pair:  https://help.github.com/articles/generating-ssh-keys

* Project manager code :noexport:
** Dependencies

#+BEGIN_SRC emacs-lisp :export code
(require 'org)  
(require 'deft)
(require 'winner)
(require 'ido)
(require 'org-colview)
(require 'browse-url)
;; (require 'workgroups)
#+END_SRC

** Setup and maintenance
*** The project manager file   
#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-default-directory
  (file-name-as-directory org-directory)
  "A place for new projects.")

(defvar org-pro-file (concat
		      (file-name-as-directory org-directory)
		      "Projects.org")
  "File for managing projects. See the manual
for structure and syntax.")
#+END_SRC

#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-project-level 4
"Subheading level at which projects are defined in `org-pro-file'.")
#+END_SRC

The project manager is in org-mode (major-mode). To bind specific
keystrokes differently in this file, the current solution is to put
a minor-mode on top of it.
    
#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-minor-mode nil)
(make-variable-buffer-local 'org-pro-minor-mode)
(defvar org-pro-minor-mode-map (make-sparse-keymap)
  "Keymap used for `org-pro-minor-mode' commands.")

(or (assq 'org-pro-minor-mode minor-mode-map-alist)
    (setq minor-mode-map-alist
	  (append minor-mode-map-alist
		  (list (cons 'org-pro-minor-mode org-pro-minor-mode-map)))))
(or (assq 'org-pro-minor-mode minor-mode-alist)
    (setq minor-mode-alist
	  (cons '(org-pro-minor-mode " Project") minor-mode-alist)))

(defun org-pro-minor-mode (&optional arg)
  "A minor mode for using org Project Manager."
  (interactive "P")
  ;; (make-variable-buffer-local 'hippie-expand-try-functions-list)
  (setq org-pro-minor-mode
	(not (or (and (null arg) org-pro-minor-mode)
		 (<= (prefix-numeric-value arg) 0))))
  (add-hook 'after-save-hook 'org-pro-refresh nil 'local))

(define-key org-pro-minor-mode-map [(meta return)] 'org-pro-return)
(define-key org-pro-minor-mode-map [(meta n)] 'org-pro-next-project)
(define-key org-pro-minor-mode-map [(meta p)] 'org-pro-previous-project)

(add-hook 'find-file-hooks 
	  (lambda ()
	    (let ((file (buffer-file-name)))
	      (when (and file (equal file (expand-file-name org-pro-file)))
		(org-pro-minor-mode)))))
#+END_SRC
   
*** Dynamically updating lists 
    
#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-project-alist nil
  "Alist of projects associating the nickname of the project
  with information like the location of the project, the index file,
  collaborator names, a category, the publishing directory, etc.")

(defvar org-pro-current-project nil "The currently selected project.")

(defvar org-pro-project-categories nil
  "List of categories for sorting projects.")

(defun org-pro-entry-get  (pom property &optional inherit literal-nil)
  "Read property and remove leading and trailing whitespace."
  (let ((prop (org-entry-get pom property inherit literal-nil)))
    (if (stringp prop) (replace-regexp-in-string "[ \t]+$" "" prop))))

(defun org-pro-parse-projects (&optional all)
  "Parse the file `org-pro-file' and update `org-pro-project-alist'."
  (interactive)
  (save-excursion
    (setq org-pro-project-alist nil)
    (set-buffer (find-file-noselect org-pro-file))
    (save-buffer)
    (goto-char (point-min))
    (while (org-pro-forward-project)
      (let* ((loc (or (org-pro-entry-get nil "LOCATION" 'inherit) org-pro-default-directory))
	     (category (org-pro-entry-get nil "CATEGORY" 'inherit))
	     (others (org-pro-entry-get nil "OTHERS" nil))
	     (publish-dir (org-pro-entry-get nil "PUBLISH" 'inherit))
	     (name (or (org-pro-entry-get nil "NICKNAME" nil)
		       (nth 4 (org-heading-components))))
	     (git (org-pro-entry-get nil "GIT" 'inherit))
	     (config (org-pro-entry-get nil "config" 'inherit))
	     (todo (substring-no-properties (or (org-get-todo-state) "")))
	     (index (or (org-pro-entry-get nil "INDEX" nil)
			(let ((default-org-home
				(concat (file-name-as-directory loc)
					name
					org-pro-org-location)))
			  ;; (make-directory default-org-home t)
			  (concat (file-name-as-directory default-org-home) name ".org")))))
	(unless (file-name-absolute-p index)
	  (setq index
		(expand-file-name (concat (file-name-as-directory loc) name "/" index))))
	(add-to-list 'org-pro-project-alist
		     (list name
			   (list (cons "location"  loc)
				 (cons "index" index)
				 (cons "category" category)
				 (cons "others" others)
				 (cons "git" git)
				 (cons "config" config)
				 (cons "state" todo)
				 (cons "publish-directory" publish-dir))))))
    org-pro-project-alist))



(defun org-pro-get-buffer-props (property)
  "Get a table of all values of PROPERTY used in the buffer, for completion."
  (let (props)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward (concat ":" property ":") nil t)
	(add-to-list 'props (list
			     (org-entry-get
			      nil property nil)))))
    props))

(defun org-pro-parse-categories ()
  "Parse the file `org-pro-file' and update `org-pro-project-categories'."
  (interactive)
  (set-buffer (find-file-noselect org-pro-file))
  (setq org-pro-project-categories
	(reverse (org-pro-get-buffer-props "CATEGORY"))))

(defun org-pro-refresh ()
  "Parses the categories and projects in file `org-pro-file' and also
           updates the currently selected project."
  (interactive)
  (org-pro-parse-categories)
  (org-pro-parse-projects)
  (when org-pro-current-project
    (setq org-pro-current-project
	  (assoc (car org-pro-current-project) org-pro-project-alist))))

#+END_SRC

*** Lists of project-index and project-org files 

#+BEGIN_SRC emacs-lisp :export code
(defun org-pro-index-list (&optional category state extension not-exist-ok update)
  "Return a list of project specific indexes.
              Projects are filtered by CATEGORY unless CATEGORY is nil.
              Projects are filtered by the todo-state regexp STATE unless STATE is nil.
              Only existing files are returned unless NOT-EXIST-OK is non-nil.
              Only files ending on EXTENSION are returned unless EXTENSION is nil.
              If UPDATE is non-nil first parse the file org-pro.
Examples:
(org-pro-index-list nil \"ACTIVE\")
(org-pro-index-list nil \"DONE\")
"
  (interactive "P")
  (when update
    (org-pro-refresh))
  (let* ((testfun (lambda (p) (when (and
				     (or (not category) (string= category (org-pro-get-category p)))
				     (or (not state) (string-match state (org-pro-get-state p)))) p)))
	 (palist (if (or category state)
		     (delq nil (mapcar testfun org-pro-project-alist))
		   org-pro-project-alist)))
    (delete-dups (delq nil (mapcar '(lambda (x)
				      (let ((f (org-pro-get-index x)))
					(when (and (or not-exist-ok (file-exists-p f))
						   (or (not extension)
						       (string= extension (file-name-extension f))))
					  f)))
				   palist)))))
  
#+END_SRC

*** The profile of a single project

#+BEGIN_SRC emacs-lisp :export code   
(defvar org-pro-org-location "/"
    "Relative to the project location this defines
  the path to the index file of a project. If set to
  'org' then the index file will be placed
  in a subdirectory 'org' of the project directory.
 The project directory is set by a property LOCATION in
the `org-pro-file'.")
#+END_SRC

#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-default-category "Unsorted" "Category for new projects.")
;; (setq org-refile-targets (quote ((org-pro :maxlevel . 3) (nil :maxlevel . 2))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :export code
(defun org-pro-set-nickname ()
  (interactive)
  (org-set-property
   "NICKNAME"
   (read-string "NickName for project: "
		(nth 4 (org-heading-components)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :export code
(defun org-pro-set-others ()
  (interactive)
  (let* ((pro (assoc (org-pro-project-at-point t)
		     org-pro-project-alist))
         (others (cdr (assoc "others" (cadr pro))))
         (init (if others (concat others ", ") "")))
    ;; (org-entry-get nil "others")
    (if pro
	(org-set-property
	 "others"
	 (replace-regexp-in-string
	  "[,\t ]+$" ""     (read-string (concat "Set collaborators for " (car pro) ": ") init))))))

(defun org-pro-fix-others ()
"Update the others property (collaborator names) of all projects in `org-pro-file'."
  (interactive "P")
  (set-buffer (find-file-noselect org-pro-file))
  (goto-char (point-min))
  (while (org-pro-forward-project)
    (org-pro-set-others)))
#+END_SRC

** Adding new projects
**** The structure template approach
     CLOSED: [2012-09-14 Fri 09:01]
#+BEGIN_SRC emacs-lisp :export code     
(add-to-list 'org-structure-template-alist
 '("P" "**** ACTIVE %?:PROPERTIES:\n:NICKNAME:\n:OTHERS:\n:CaptureDate:\n:END:"))
#+END_SRC

**** The interactive approach     
     
#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-default-content "" "Initial contents of org project index file.")
(defvar org-pro-project-subdirectories nil)
(defun org-pro-create-project (&optional project ask)
  "Create the index file, the project directory, and subdirectories if
                                  'org-pro-project-subdirectories' is set."
  (interactive)
  (let ((pro (assoc project org-pro-project-alist)))
    (when pro
      (let ((dir (concat (org-pro-get-location pro) (car pro)))
	    (index (org-pro-get-index pro)))
	(when (and index (not (file-exists-p index)))
	  (unless (file-exists-p (file-name-directory index))
	    (make-directory (file-name-directory index) t))
	  (find-file index))
	;; (append-to-file org-pro-default-content nil index)
	(unless (or (not dir) (file-exists-p dir) (not (and ask (y-or-n-p (concat "Create directory (and default sub-directories) " dir "? ")))))
	  (make-directory dir)
	  (loop for subdir in org-pro-project-subdirectories
		do (unless (file-exists-p subdir) (make-directory (concat path subdir) t))))
	(find-file org-pro-file)
	(goto-char (point-min))
	(re-search-forward (concat (make-string org-pro-project-level (string-to-char "*")) ".*" (car pro)) nil )))))


(defun org-pro-move-project (&optional project)
  (interactive)
  (let* ((pro (or project (org-pro-select-project)))
	 (index (org-pro-get-index pro))
	 (dir (concat (org-pro-get-location pro) (car pro)))
	 (target  (read-directory-name (concat "Move all files below " dir " to: " )))
	 (new-index (unless (string-match dir (file-name-directory index))
		      (read-file-name (concat "Move " index " to ")))))
    (if (string= (file-name-as-directory target) target)
	(setq target (concat target (file-name-nondirectory dir))))
    (unless (file-exists-p (file-name-directory target)) (make-directory (file-name-directory target)))
    (when (yes-or-no-p (concat "Move " dir " to " target "? "))
      (rename-file dir target)
      (if (and new-index (yes-or-no-p (concat "Move " index " to " new-index "? ")))
	  (rename-file index new-index))
      (org-pro-goto-profile pro)
      (org-set-property "LOCATION" (file-name-directory target))
      (org-set-property "INDEX" (or new-index (replace-regexp-in-string (file-name-directory dir) (file-name-directory target) index)))
      (save-buffer))))


(defun org-pro-delete-project (&optional project)
  (interactive)
  (let* ((pro (or project (org-pro-select-project)))
	 (dir (concat (org-pro-get-location pro) (car pro)))
	 (index (org-pro-get-index pro)))
    (pop-to-buffer "*Org-project-files*")
    (erase-buffer)
    (insert index "\n" dir "\n")
    (when (yes-or-no-p (concat "Really remove project " (car pro) "? "))
      (when (file-exists-p dir) (move-file-to-trash dir))
      (when (file-exists-p index) (move-file-to-trash index))
      (find-file org-pro-file)
      (goto-char (point-min))
      (re-search-forward (concat ":NICKNAME:.*" (car pro)) nil t)
      (org-mark-subtree)
      (when (yes-or-no-p (concat "Is this project entry to be deleted " (car pro) "?"))
        (kill-region (region-beginning) (region-end))))))


(defun org-pro-new-project (&optional nickname category)
  "Create a new project. Prompt for CATEGORY and NICKNAME if necessary.
                This function modifies the 'org-pro' and creates and visits the index file of the new project.
                Thus, to undo all this you may want to call 'org-pro-delete-project'. 
                " 
  (interactive)
  (org-pro-refresh)
  (let* ((nickname (or nickname (read-string "Project name (short) ")))
	 category)
    ;; check if nickname exists 
    (while (assoc nickname org-pro-project-alist)
      (setq nickname
	    (read-string (concat "Project " nickname " exists. Please choose a different name (C-g to exit): "))))
    (setq category (or category (completing-read "Category: " (org-pro-parse-categories) nil nil)))
    ;; a local capture command places the new project
    (let ((org-capture-templates
	   `(("p" "Project" plain
	      (file+headline org-pro-file ,category)
	      ,(concat (make-string org-pro-project-level (string-to-char "*"))
		       " ACTIVE " nickname "%?\n:PROPERTIES:\n:NICKNAME: "
		       nickname
		       "\n:LOCATION: \n:CATEGORY: " category "\n:INDEX: \n:GIT: \n:OTHERS: \n:END:\n"))))
	  (org-capture-bookmark nil))
      (add-hook 'org-capture-mode-hook '(lambda () (define-key org-capture-mode-map [(tab)] 'org-pro-complete-property)) nil 'local)
      (add-hook 'org-capture-after-finalize-hook `(lambda () (org-pro-create-project ,nickname 'ask)) nil 'local)
      ;;(add-hook 'org-capture-mode-hook 'org-pro-show-properties nil 'local)
      (org-capture nil "p")
      )))


(defun org-pro-show-properties ()
  (let ((pop-up-windows t)
	(obuf (current-buffer))
	(pbuf (get-buffer "*Org project manager properties*")))
    (set-buffer pbuf)
    (erase-buffer)
    (insert "Current project categories:\n\n")
    (mapcar '(lambda (x) (if (car x) (insert (car x) ", "))) org-pro-project-categories)
    (delete-backward-char 2)
    (insert "\n\n")
    (pop-to-buffer pbuf)
    (pop-to-buffer obuf)))


(defun org-pro-complete-property ()
  (interactive)
  (let ((curprop (save-excursion (beginning-of-line) (looking-at ".*:\\(.*\\):") (org-match-string-no-properties 1))))
    (cond ((string= (downcase curprop) "index")
	   (insert (read-file-name (concat "Set " curprop ": "))))
	  ((string= (downcase curprop) "location")
	   (insert (read-directory-name (concat "Set " curprop ": ")))))))
#+END_SRC

** The project manager
#+BEGIN_SRC emacs-lisp  :export code
(defun org-pro-goto-project-manager ()
  (interactive)
  (find-file org-pro-file))

(defun org-pro-project-at-point (&optional noerror)
  "Check if point is at project heading and return the project,
        i.e. its entry from the 'org-pro-project-alist'.
        Otherwise return error or nil if NOERROR is non-nil. "
  (interactive)
  ;; (org-back-to-heading)
  (if (or (org-before-first-heading-p)
	  (not (org-at-heading-p))
	  (not (= org-pro-project-level
		  (- (match-end 0) (match-beginning 0) 1))))
      (if noerror nil
	(error "No project at point"))
    (or (org-entry-get nil "NICKNAME")
	(progn (org-pro-set-nickname)
	       (save-buffer) ;; to update the project-alist
	       (org-entry-get nil "NICKNAME")))))

(defun org-pro-goto-profile (project)
  (let ((case-fold-search t))
    (find-file org-pro-file)
    (goto-char (point-min))
    (or (re-search-forward (concat "^[ \t]*:NICKNAME:[ \t]*" (car project)) nil t)
	(error (concat "Cannot locate project " (car project))))))

(defun org-pro-return ()
  (interactive)
  (let* ((pro (assoc (org-pro-project-at-point)
		     org-pro-project-alist)))
    (delete-other-windows)
    (split-window-horizontally 25)
    (other-window 1)
    (find-file (org-pro-get-index pro))
    (split-window-vertically 13)
    (switch-to-buffer "*Current project*")
    (erase-buffer)
    (insert (car pro) "\n------------------------------\n")
    (mapc (lambda (x) (insert (car x) ": " (if (cdr x) (cdr x) "")  "\n")) (cadr pro))
    (other-window 1)))

(defun org-pro-forward-project ()
  (interactive)
  (re-search-forward
   (format "^\\*\\{%d\\} " org-pro-project-level) nil t))

(defun org-pro-backward-project ()
  (interactive)
  (re-search-backward
   (format "^\\*\\{%d\\} " org-pro-project-level) nil t))

(defun org-pro-next-project (arg)
  (interactive  "p")
  (org-pro-forward-project)
  (org-pro-return))

(defun org-pro-previous-project (arg)
  (interactive  "p")
  (org-pro-backward-project)
  (org-pro-return))
#+END_SRC

** Git control


#+BEGIN_SRC emacs-lisp :export code 
(setq org-property-set-functions-alist nil)  
(add-to-list 'org-property-set-functions-alist
	     `("GitStatus" . org-pro-git-status-file-at-point))
(add-to-list 'org-property-set-functions-alist
	     `("LastCommit" . org-pro-git-commit-file-at-point))

(defvar org-pro-use-git t "Whether to use git to backup projects. Set to nil to completely disable git.
                                                   If non-nil, git is controlled on per project basis using properties set in `org-pro'.")

(setq org-pro-git-ignore "*")
(defvar org-pro-git-ignore "*" "What files to include or not include. See M-x manual-entry RET gitignore.
                                      
                                   By default we set this to '*' which means that all files are ignored.
                                      
                                   You think this is a bit stupid? Hehe, we can still add files via
                                   the -f (force) command line switch. And we get not bothered by
                                   having to filter all the unpredictable names one can give to files
                                   that never should get git controlled.")

(defun org-pro-git-p (dir)
  "Test if directory DIR is under git control."
  (eq 0 (shell-command (concat "cd " dir ";git rev-parse --is-inside-work-tree "))))

(defun org-pro-git-init-project (&optional pro)
  "Put project under git control."
  (interactive)
  (let* ((pro (or pro (org-pro-select-project)))
	 (index (org-pro-get-index pro))
	 (loc (concat (org-pro-get-location pro) (car pro))))
    (if (not index)
	(error (concat "Trying to org-pro-git-init-project: Project " (car pro) " has no index file."))
      (org-pro-git-init-directory loc)
      (if (string-match loc index)
	  (org-pro-git-add-and-commit-file
	   index loc (concat "Initial commit of project " (car pro)))))))

(defun org-pro-git-init-directory (dir)
  "Put directory DIR under git control."
  (if (org-pro-git-p dir)
      (message (concat "Directory " dir " is under git control."))
    (shell-command (concat "cd " dir "; git init"))
    (append-to-file org-pro-git-ignore nil (concat (file-name-as-directory dir) ".gitignore"))))

(defun org-pro-filename-at-point ()
  (let* ((file-or-link (org-pro-entry-get nil "filename" t)))
    (if (string-match org-bracket-link-regexp file-or-link)
	(expand-file-name
	 (org-extract-attributes
	  (org-link-unescape (org-match-string-no-properties 1 file-or-link))))
      (if (file-exists-p file-or-link)
	  (expand-file-name file-or-link)))))

(defun org-pro-read-git-date (git-date-string &optional no-time)
  "Transform git date to org-format"
  (with-temp-buffer
    (org-insert-time-stamp 
     (date-to-time git-date-string) (not no-time))))
;;      (set-time-zone-rule t) ;; Use Universal time.
;;      (prog1 (format-time-string "%Y-%m-%d %T UTC" time)
;;        (set-time-zone-rule nil))))

(defun org-pro-git-get-commit (arg file &optional dir)
  (interactive)
  (let* ((dir (cond (dir) ((file-name-absolute-p file) (file-name-directory file))
		    (t (read-directory-name (concat "Find the git directory of file " file ": ")))))
	 (date (org-pro-read-git-date
		(shell-command-to-string
		 (if (string= arg "first")
		     (concat  "cd " dir ";git log --date=local --pretty=format:\"%ad\" --reverse " file "  | head -1")
		   (concat "git log --date=local -" arg " --pretty=format:\"%ad\" " file)))))
	 (mess (shell-command-to-string
		(if (string= arg "first")
		    (concat "cd " dir ";git log --reverse --pretty=format:\"%s\" " file " | head -1")
		  (concat "git log -" arg " --pretty=format:\"%s\" " file)))))
    (concat date " " mess)))


(defun org-pro-git-status-file-at-point (&rest args)
  (interactive)
  (let* ((file (org-pro-filename-at-point))
	 (dir (if file (file-name-directory file)))
	 (git-status (shell-command-to-string (concat "cd " dir "; git status --ignored --porcelain " file)))
	 git-last-commit
	 status)
    (if (not (org-pro-git-p dir))
	(error (concat "Directory " dir " is not git controlled. You may want to start\ngit control of the project via M-x `org-pro-git-init-project'."))
      (if (string= git-status "")
	  (if (file-exists-p file)
	      (setq git-status "C")
	    (setq git-status "E"))
	(if (string-match "^fatal" git-status)
	    (setq git-status "")
	  (setq git-status (substring git-status 0 1))))
      (if (string= git-status "!") (setq git-status "?"))
      (if (or  (string= git-status "") (string= git-status "E") (string= git-status "?"))
	  (setq git-last-commit "")
	(setq git-last-commit (org-pro-git-get-commit "1" file dir) ))
      (cond ((string= git-status "?")
	     (setq status "Untracked"))
	    ((string= git-status "E")
	     (setq status "File does not exist"))
	    ((string= git-status "M")
	     (setq status "Modified and staged"))
	    ((string= git-status "A")
	     (setq status "New file"))
	    ((string= git-status " ")
	     (setq status "Modified but unstaged"))
	    ((string= git-status "C")
	     (setq status "Committed"))
	    (t (setq status "Unknown")))
      (org-set-property "GitStatus" status)
      (unless (or (string= git-status "E") (string= git-status "?"))
	(unless (org-pro-entry-get nil "GitInit")
	  (org-set-property "GitInit" (org-pro-git-get-commit "first" file)))
	(unless (string= git-last-commit "")
	  (org-set-property "LastCommit" git-last-commit))
	(if args 
	    (if (string= (car args) "1") git-last-commit status))
	)
      )))

(defun org-pro-git-add-file (file project)
  (interactive)
  (let* ((pro (or project (org-pro-select-project)))
	 (dir (concat (org-pro-get-location pro) (car pro)))
	 (file (or file (read-file-name "Git add file: " dir nil t))))
    (shell-command (concat "cd " dir "; git add -f " file))))

(defun org-pro-git-add-and-commit-file (file dir &optional message)
  (shell-command (concat "cd " dir
			 "; git add -f " file "; git commit -m\" "
			 (or message 
			     (read-string (concat "Commit message for " (file-name-nondirectory file) ": ")))
			 "\" " file)))

;;(defun org-pro-buffer-file-project ()
;; "Return the project of the current buffers file."
;;  (let ((f (buffer-file-name (current-buffer))))

(defun org-pro-git-add-file-at-point ()
  "Add or update file FILE to git repository DIR."
  (interactive)
  (let* ((file (org-pro-filename-at-point))
	 (dir (if file (file-name-directory file))))
    (org-pro-git-add-file file
			  (if (string= (expand-file-name (buffer-file-name))
				       (expand-file-name (org-pro-get-index org-pro-current-project)))
			      org-pro-current-project
			    nil))
    (org-pro-git-status-file-at-point "1")
    ))

(defun org-pro-git-commit-file-at-point (&rest args)
  "Add or update file FILE to git repository DIR."
  (interactive)
  (let* ((file (org-pro-filename-at-point))
	 (dir (if file (file-name-directory file)))
	 (message (read-string (concat "Commit message for " (file-name-nondirectory file) ": "))))
    (org-pro-git-add-and-commit-file file dir message)
    (org-pro-git-status-file-at-point "1")
    ))

(defun org-pro-git-push-directory (dir silent)
  "Git push directory DIR."
  (let* ((status (shell-command-to-string  (concat "cd " dir "; git status")))
	 (necessary (string-match "Your branch is ahead .*\n" status))
	 (doit (or silent (y-or-n-p (concat "Your branch is ahead ... push git at " dir "? ")))))
    (if doit
	(shell-command (concat "cd " dir "; git push")))))


(defun org-pro-git-update-project (project before)
  "Check if project needs to be put under git control and update.
                                   If BEFORE is set then either initialize or pull. Otherwise, add, commit and/or push.
                                  "
  (let* ((git-control (downcase (org-pro-get-git project))))
    (unless (or (string= git-control "") (string-match "no\\|never\\|nil" git-control))
      (let ((silent-p (string= git-control "silent"))
	    (dir (org-pro-get-git-location project)))
	(when (file-exists-p dir)
	  (if before
	      (progn
		;; activating project
		(unless (or (org-pro-git-p dir) (string-match "no" git-control) (string= "" git-control))
		  (when (or silent-p
			    (y-or-n-p (concat "Initialize git control at " dir "?")))
		    (org-pro-git-init-directory dir)))
		(when (and (string-match "pull" git-control)
			   (or silent-p (y-or-n-p (concat "Run this command: \"git pull\" at " dir "? "))))
		  (shell-command (concat "cd " dir "; git pull"))))
	    ;; deactivating project
	    (when (and (org-pro-git-p dir)
		       (string-match "yes\\|silent" git-control))
		)))))))


#+END_SRC   

** Column view

Insert something like this in '* Documents' section (or globally)

#+BEGIN_EXAMPLE
#+COLUMNS: %20ITEM(Title) %8TODO(ToDo) %GitStatus %50LastCommit(Last Commit)
;; Default: %25ITEM %TODO %3PRIORITY %TAGS"
#+END_EXAMPLE

Right now we will set this globally. But it may be preferable to do
this on file basis - perhaps added to each property by the appropiate
capture mechanism.

#+BEGIN_SRC emacs-lisp :export code    
(org-defkey org-columns-map "\r" 'org-pro-column-action) ;; Return is not used anyway in column mode
(org-defkey org-columns-map "l" 'org-pro-git-log-at-point) ;; Return is not used anyway in column mode
(org-defkey org-columns-map "t" 'org-pro-git-tag-at-point) ;; Return is not used anyway in column mode
(org-defkey org-columns-map "u" '(lambda () ;; Return is not used anyway in column mode
				   (interactive)
				   (if (org-pro-entry-get nil "columns" nil)
				       (org-pro-update-status)
				     
                                     (org-pro-git-status-file-at-point)     
				     )
				   (org-columns-redo)))
(org-defkey org-columns-map "C" '(lambda () (interactive)(org-pro-git-commit-file-at-point)(org-columns-redo)))
(defun org-pro-column-action ()
  (interactive)
  (let* (
	 (prop (get-char-property (point) 'org-columns-key))
	 )
    (cond ((string= prop "ITEM")
	   ;;        (org-pro-git-status-file-at-point)
	   (save-excursion
	     (org-narrow-to-element)
	     (if (re-search-forward ":Hash:" nil t)
		 (progn 
		   (widen)
		   (org-pro-git-revision-at-point)))
	     (if (re-search-forward ":FileName:" nil t)
		 (progn 
		   (widen)
		   (org-open-at-point)
		   )
	       (widen)) 
	     ))
	  ((string= prop "GitStatus")
	   (org-pro-git-status-file-at-point)
	   )
	  ((string= prop "Decoration")
	   (org-pro-git-tag-at-point)
	   )
	  ((string= prop "FileName")
	   (org-columns-open-link)
	   )
	  ((string= prop "Other")
	   (org-columns-open-link)
	   )
	  ((string= prop "Hash")
	   (org-pro-git-revision-at-revision)
	   )
	  ((string= prop "LastCommit")
	   (org-pro-git-commit-file-at-point)
	   )
	  (t (org-columns-edit-value)))
    (org-columns-redo)
    ))


(defun org-pro-update-status ()
  (interactive)
  (save-excursion 
    (goto-char (point-min))
    (org-columns-quit)
    (while (re-search-forward ":GitStatus:" nil t)
      (org-pro-git-status-file-at-point)
      (org-end-of-line)
      )
    (goto-char (point-min))
    (re-search-forward "\\* Documents" nil t)
    (org-columns)
    )
  )

(defvar org-pro-view nil)
(make-variable-buffer-local 'org-pro-view)
(defun org-pro-view (&optional status) 
  (interactive)
  (setq org-pro-view (or status (not org-pro-view)))
  (if org-pro-view
      (progn 
	(org-narrow-to-subtree)
	(goto-char (point-min))
	(org-columns)
	(org-columns-content)
	)
    (progn 
      (widen)
      (org-columns-quit)
      (hide-subtree))
    ))

;; (add-hook 'org-mode-hook (lambda ()
;;                         (local-set-key (kbd "C-x c") 'org-pro-view)))


(defvar org-pro-log-limit 500)
(defun org-pro-git-log-at-point (&optional file)
  (interactive)
  (widen)
  (let ((gitlog) (result) (item) (val) (myfile) (gitpath))
    (setq myfile (file-relative-name (or file  
					 (org-pro-filename-at-point))))
    (setq gitpath (replace-regexp-in-string myfile "" (expand-file-name myfile)))
    (setq gitlog
	  (split-string (substring 
			 (shell-command-to-string 
			  (concat "git log --pretty=\"%h#&#%s#&#%ad#&#%an#&#%d\" --date short " 
				  (if org-pro-log-limit (concat "-n " (int-to-string org-pro-log-limit))) "-- " myfile))
			 0 -1) "\n"))
    ;;  (generate-new-buffer "*org-pro-git-scratch*")
    (switch-to-buffer "*org-pro-git-scratch*")
    (org-columns-quit)
    (erase-buffer)
    (insert-string (concat "* Git Log (" myfile ")\n:PROPERTIES:\n:COLUMNS: %40ITEM(Comment) %Date %15Author %15Decoration %8Hash \n:FileName: " myfile "\n:GitPath: " gitpath "\n:END:\n"))
    (setq result "")
    (loop for x in gitlog
	  do 
	  (setq val (delete "" (split-string x "#&#")))
	  (setq item (concat "*** " (nth 1 val) "\n:PROPERTIES:\n:Hash: " (car val) "\n:Date: " (nth 2 val) "\n:Author: " (nth 3 val) "\n:Decoration: " (nth 4 val) "\n:END:\n"))
	  (setq result (concat result item)))
    (insert-string result)
    (org-mode)
    (org-columns)
    (org-columns-content)
    (goto-char (point-min))
    ))


(defun org-pro-git-tag-at-point (&optional tag)
  "Set git tag"
  (interactive)
  (let ((myhash (org-pro-entry-get nil "hash" nil))
	(mytag  (org-pro-entry-get nil "decoration" nil))
	(mypath  (org-pro-entry-get nil "gitpath" t))
	(tag (read-string "Tag (empty to clear): "))
	)
    (if (string-equal tag "")
	(progn 
	  (setq mytag (replace-regexp-in-string "\)" "" (replace-regexp-in-string "\(" "" mytag)))
	  (shell-command (concat "cd " mypath "; git tag -d " mytag))
	  )
      (shell-command (concat "cd " mypath "; git tag -a " tag " " myhash " -m \"\"")))
    ) 
  (save-excursion
    (goto-char (point-min))
    (org-pro-git-log-at-point)
    )
  )

(defun org-pro-git-revision-at-point ()
  (interactive)
  (let ((myhash (org-pro-entry-get nil "hash" nil))
	(myfile (org-pro-entry-get nil "filename" t))  
	(mypath (org-pro-entry-get nil "gitpath" t))  
	(mystr))
    (setq mystr (shell-command-to-string 
		 (concat "cd " mypath "; git show " myhash ":" myfile)))
    (switch-to-buffer-other-window (concat myfile "." myhash))
    (text-mode)
    (erase-buffer)  
    (insert-string mystr)
    ;;   (goto-char (point-min))
    ))


#+END_SRC

#+RESULTS[e36ae81b63d6874a18e8e715f152ccf924533133]:
: org-pro-git-revision-at-point

** Window configuration

It may be counterintuitive, but saving a window configuration is not
so easy. One reason is that unsaved, temporary stuff like
file-unrelated buffers cannot be restored. Also, the dimensions of
frames and windows depend on the current screen and most people will
at least occasionally work on different screens.

What we could do is restore from saved files and certain
file-unrelated buffers, as for example a buffer showing a shell. We
can also save the number of windows and the horizontal and vertical
splits in the current frame. 

#+BEGIN_SRC  emacs-lisp :export code
(setq org-pro-default-config "INDEX")
(setq org-pro-sticky-config nil)

(defvar org-pro-file-manager "file-list")

;; could be 
;; (setq org-pro-sticky-config "recent.org / *R* | TODO")
(setq org-pro-config-action-alist '(("INDEX" . org-pro-find-index)
				    ("TODO" . org-pro-todo)
				    ("TIMELINE" . org-pro-timeline)
				    ("LOCATION" . org-pro-location)
				    ("FILELIST" . org-pro-file-list)
				    ("magit" . org-pro-magit)
				    ("recent.org" . org-pro-recent-org)
				    ("*shell*" . (lambda (project) (if (get-buffer "*shell*") (switch-to-buffer "*shell*") (shell))))
                                    ("*ielm*" . (lambda (project) (if (get-buffer "*ielm*") (switch-to-buffer "*ielm*") (ielm))))
				    ("*R*" . org-pro-find-R-function)))

(defvar org-pro-find-R-function
  "Function used to find *R*"
  (lambda (project) (if (get-buffer "*R*") (switch-to-buffer "*R*") (R))))

(defun org-pro-find-index (project)
  (let* ((index (org-pro-get-index project)))
    (unless (file-exists-p index)
      (unless (file-exists-p (file-name-directory index))
	(make-directory (file-name-directory index) 'with-parents))
      (make-directory (file-name-directory index) 'with-parents))
    (find-file index)))

(defun org-pro-file-list (project)
  (if (featurep 'file-list)
      (let ((loc (concat (org-pro-get-location project) (car project))))
	(cond ((file-list-select-internal nil "." nil nil loc (concat "*File-list-" (car project) "*")))
	      (t
	      (switch-to-buffer (concat "*File-list-" (car project) "*"))
	      (toggle-read-only -1)
              (erase-buffer)
	      (insert "FILE-LIST: No files in project"))))
	(error "file-list.el not loaded.")))


  (defun org-pro-find-thing (thing project)
    (let* ((case-fold-search t)
	   (action (cdr (assoc (replace-regexp-in-string "^[ \t\n]+\\|[ \t\n]+$" ""  (car thing))
			       org-pro-config-action-alist))))
      (cond ((functionp action) (funcall action project))
	    ((and (car thing) (file-name-directory (car thing)))
	     (find-file (expand-file-name
			 (car thing) (concat (org-pro-get-location project) (car project)))))
	    (t (switch-to-buffer (car thing))))))

  (defun org-pro-read-config-list (string)
    ;; return a list of lists with vertical splits 
    ;; where each element can have horizontal splits
    (split-string string "[ \t]+:[ \t]+"))

  (defun org-pro-read-config (config &optional pos)
    ;; return a list with horizontal splits 
    ;; where each element can have vertical splits
    (let* ((vlist (split-string config "[ \t]+|[ \t]+"))
	   (hlist (mapcar '(lambda (x) (split-string x "[ \t]+/[ \t]+")) vlist)))
      hlist))


  (defun org-pro-save-config (&optional config project)
    (interactive)
    (let ((conf (or config (org-pro-current-config)))
	  (pro (or project org-pro-current-project (org-pro-select-project))))
      (find-file-other-window (concat (org-pro-get-location pro) (car pro) "/.org-pro-window-config"))
      (goto-char (point-max))
      (unless (looking-at "^$") (insert "\n"))
      (insert conf)
      (save-buffer)))

  (defun org-pro-current-config ()
    (let* ((windata (winner-win-data))
	   config
	   prev-row)
      (while windata
	(let* ((buf (cdr (car windata)))
	       (pos (car (car windata)))
	       ;;	     (col (nth 0 pos))
	       (row (nth 1 pos))
	       (thing
		(cond 
		 ((buffer-file-name buf)
		  (replace-regexp-in-string (getenv "HOME") "~"  (buffer-file-name buf)))
		 ;; (get-buffer-process buf)
		 (t (buffer-name buf)))))
	  (setq config (concat config (when prev-row (if (< prev-row row) " / " " | ")) thing))
	  (setq windata (cdr windata))
	  (setq prev-row row)))
      config))


  (defvar org-pro-config-cycle-pos 0 "Position in the current window configuration cycle. Starts at 0.")


  (defun org-pro-get-config (project)
    (let* ((config (or org-pro-sticky-config org-pro-default-config "INDEX"))
	   (config-file  (concat (org-pro-get-location project) (car project) "/.org-pro-window-config"))
	   (filed-config (when (file-exists-p config-file)
			   (save-window-excursion
			     (find-file config-file)
			     (replace-regexp-in-string "\n" " : "  (replace-regexp-in-string "[\n\t ]+$" "" (buffer-string))))))
	   (prop-config (cdr (assoc "config" (cadr project)))))
      (if (not config)
	  (setq config prop-config)
	(when filed-config
	  (setq config (concat config " : " filed-config)))
	(when prop-config
	  (setq config (concat config " : " prop-config)))
	config)))


  (defun org-pro-set-config (&optional project config pos)
    (interactive)
    (let* ((pro (or project org-pro-current-project (org-pro-select-project)))
	   (conf (or config (org-pro-get-config pro)))
	   (pos (or pos org-pro-config-cycle-pos 0))
	   (window-config (org-pro-read-config (nth pos (org-pro-read-config-list conf))))
	   (ncolumns (length window-config))
	   top-windows)
      ;;(message conf)
      (delete-other-windows)
      (setq top-windows (list (selected-window)))
      (loop for n from 1 to (- ncolumns 1) do
	    (split-window-horizontally)
	    (other-window 1)
	    (setq top-windows (append top-windows (list (selected-window)))))
      (loop for n from 0 to (- ncolumns 1) do 
	    (select-window (nth n top-windows))
	    (let ((el (nth n window-config)))
	      (while el
		(org-pro-find-thing el pro)
		(setq el (cdr el))
		(when el (split-window-vertically) (other-window 1)))))
      (select-window (nth 0 top-windows))))
#+END_SRC

** Hacking deft

#+BEGIN_SRC  emacs-lisp :export code
;; Hack to search project index files
;; and to start new projects via deft 
(defun deft-local-setup ()
  ;; (kill-all-local-variables)
  (make-variable-buffer-local 'deft-buffer)
  (make-variable-buffer-local 'deft-directory)
  (make-variable-buffer-local 'deft-current-files)
  (make-variable-buffer-local 'deft-all-files)
  (make-variable-buffer-local 'deft-filter-regexp)
  (make-variable-buffer-local 'deft-find-all-files-function)
  (make-variable-buffer-local 'deft-new-file-function)
  (make-variable-buffer-local 'deft-filter-match-file-function)
  (make-variable-buffer-local 'deft-hash-mtimes)
  (make-variable-buffer-local 'deft-hash-contents)
  (make-variable-buffer-local 'deft-hash-titles)
  (make-variable-buffer-local 'deft-hash-summaries)
  (setq truncate-lines t)
  (setq buffer-read-only t)
  (setq default-directory deft-directory)
  (use-local-map deft-mode-map)
  (deft-cache-initialize)
  (deft-cache-update-all)
  (deft-filter-initialize)
  (setq major-mode 'deft-mode)
  (deft-set-mode-name)
  (deft-buffer-setup) ;; calls deft-refresh
  (when (> deft-auto-save-interval 0)
    (run-with-idle-timer deft-auto-save-interval t 'deft-auto-save))
  (run-mode-hooks 'deft-mode-hook))

(defun deft-local-mode ()
  ;; (kill-all-local-variables)
  (setq truncate-lines t)
  (setq buffer-read-only t)
  (setq default-directory deft-directory)
  (use-local-map deft-mode-map)
  (deft-cache-initialize)
  (deft-cache-update-all)
  (deft-filter-initialize)
  (setq major-mode 'deft-mode)
  (deft-set-mode-name)
  (deft-buffer-setup) ;; calls deft-refresh
  (when (> deft-auto-save-interval 0)
    (run-with-idle-timer deft-auto-save-interval t 'deft-auto-save))
  (run-mode-hooks 'deft-mode-hook))

(defvar deft-new-file-function 'deft-new-file-local)
(defvar deft-find-all-files-function 'deft-find-all-files-local)
(defvar deft-filter-match-file-function 'deft-filter-match-file-local)

(defun deft-filter-match-file (file &optional batch)
  (funcall deft-filter-match-file-function file batch))
(defun deft-find-all-files ()
  (funcall deft-find-all-files-function))
(defun deft-new-file ()
  (funcall deft-new-file-function))

;; copy of original deft-find-all-files
(defun deft-find-all-files-local (&optional dir)
  "Return a list of all files in the Deft directory."
  (let ((dir (or dir deft-directory)))
    (if (file-exists-p dir)
	(let (files result)
	  ;; List all files
	  (setq files
		(directory-files dir t
				 (concat "\." deft-extension "$") t))
	  ;; Filter out files that are not readable or are directories
	  (dolist (file files)
	    (when (and (file-readable-p file)
		       (not (file-directory-p file)))
	      (setq result (cons file result))))
	  result))))

;; copy of original deft-filter-match-file
(defun deft-filter-match-file-local (file &optional batch)
  "Return FILE if FILE matches the current filter regexp."
  (let ((dfr deft-filter-regexp)
        (dhc deft-hash-contents)
        (dhs deft-hash-summaries)
        (dht deft-hash-titles)
        (dhm deft-hash-mtimes))
    (with-temp-buffer
      (make-variable-buffer-local 'deft-filter-regexp)
      (make-variable-buffer-local 'deft-hash-summaries)
      (make-variable-buffer-local 'deft-hash-titles)
      (make-variable-buffer-local 'deft-hash-contents)
      (make-variable-buffer-local 'deft-hash-mtimes)
      (setq deft-filter-regexp dfr
            deft-hash-contents  dhc 
	    deft-hash-summaries dhs
	    deft-hash-titles dht
	    deft-hash-mtimes dhm)
      (setq deft-filter-regexp dfr)
      (insert file)
      (insert (deft-file-title file))
      (insert (deft-file-contents file))
      (if batch
	  (if (every (lambda (filter)
		       (goto-char (point-min))
		       (deft-search-forward filter))
		     deft-filter-regexp)
	      file)
	(goto-char (point-min))
	(if (deft-search-forward (car deft-filter-regexp))
	    file)))))

;; hack for new files
(defun deft-file-mtime (file)
  "Retrieve modified time of FILE from cache."
  (when deft-hash-mtimes
  (gethash file deft-hash-mtimes)))

;; copy of original def-new-file
(defun deft-new-file-local ()
  "Create a new file quickly, with an automatically generated filename
or the filter string if non-nil and deft-use-filename-as-title is set.
If the filter string is non-nil and title is not from filename,
use it as the title."
  (interactive)
  (let (filename)
    (if (and deft-use-filename-as-title deft-filter-regexp)
	(setq filename (concat (file-name-as-directory deft-directory) (deft-whole-filter-regexp) "." deft-extension))
      (let (fmt counter temp-buffer)
	(setq counter 0)
	(setq fmt (concat "deft-%d." deft-extension))
	(setq filename (concat (file-name-as-directory deft-directory)
			       (format fmt counter)))
	(while (or (file-exists-p filename)
		   (get-file-buffer filename))
	  (setq counter (1+ counter))
	  (setq filename (concat (file-name-as-directory deft-directory)
				 (format fmt counter))))
	(when deft-filter-regexp
	  (write-region (concat (deft-whole-filter-regexp) "\n\n") nil filename nil))))
    (deft-open-file filename)
    (with-current-buffer (get-file-buffer filename)
      (goto-char (point-max)))))

(defun org-pro-deft-new-project ()
  "Create a new project quickly."
  (interactive)
  (org-pro-new-project (deft-whole-filter-regexp)))

(defun org-pro-deft ()
  (interactive)
  (switch-to-buffer "*deft projects*")
  (deft-mode)
  (deft-local-setup)
  (setq deft-directory org-pro-default-directory)
  (setq deft-find-all-files-function 'org-pro-index-list)
  (setq deft-new-file-function 'org-pro-deft-new-project)
  (setq deft-buffer (current-buffer))
  (deft-local-mode))

#+END_SRC

** Selecting projects
*** Agenda 
#+BEGIN_SRC emacs-lisp :export code
(defun org-pro-project-agenda ()
    "Show an agenda of all the projects. Useful, e.g. for toggling
the active status of projects."
    (interactive)
    (find-file org-pro-file)
    (push ?t unread-command-events)
    (push ?< unread-command-events)
    (call-interactively 'org-agenda))
;;     (defun org-pro-agenda ()
;;      (interactive)
;;      (let ((org-agenda-files
;;             (delq nil (mapcar '(lambda (x) (let ((f (org-pro-get-index x))) (if (file-exists-p f) f))) 
;;                               (org-pro-parse-projects))))
;;            (org-agenda-include-diary nil))
;;            (org-agenda-list)))

#+END_SRC

*** Selecting a project from the project-alist
#+BEGIN_SRC emacs-lisp :export code    
(defun org-pro-format-project (entry)
        (let ((cat (org-pro-get entry "category"))
              (coll (org-pro-get entry "others"))
              (nickname (car entry)))
          (cons
           ;; (format format cat (if coll coll "") nickname)
           (concat cat "/" (if coll (concat coll "/")) (car entry))
           (car entry))))
      
(defun org-pro-select-project ()
        "Select a project from the project alist, 
    which is modified such that 'org-pro-current-project'
    is the first choice."
        (let* ((plist org-pro-project-alist)
               (project-array (mapcar 'org-pro-format-project
                                      (if (not org-pro-current-project)
                                          plist
                                        (setq plist (append (list org-pro-current-project)
                                                (remove org-pro-current-project plist))))))
               (completion-ignore-case t)
               (key (ido-completing-read "Project: " (mapcar 'car project-array)))
               (nickname (cdr (assoc key project-array))))
          (assoc nickname org-pro-project-alist)))
                
#+END_SRC

*** Activating a project

IDEA: let the current project appear in the frame title or in the mode line

See http://www.emacswiki.org/emacs/frame-cmds.el


#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-frame-title-format t
  "If non-nil add the nickname of the active project to frame-title")


(defun org-pro-set-frame-title ()
  (let* ((old-format (split-string frame-title-format "Project:[ \t]+[^ \t]+[ \t]+"))
        (keep (if (> (length old-format) 1) (cadr old-format) (car old-format))))
    (setq frame-title-format
          (concat "Project: " (or (car org-pro-current-project) "No active project") " " keep))))

(defun org-pro-activate-project (project)
  "Sets the current project.
            Start git, if the project is under git control, and git is not up and running yet."
  (setq org-pro-current-project project)
  (if org-pro-frame-title-format
      (org-pro-set-frame-title))
  ;; maybe activate git control
  (when org-pro-use-git 
    (org-pro-git-update-project project 'before)))
#+END_SRC

*** Saving the current project

#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-save-buffers 'save-some-buffers
    "Function to be called to save buffers before switching project.")
(defun org-pro-save-project (&optional project)
    (interactive)
    (when (and (object-p org-pro-save-buffers)
               (functionp org-pro-save-buffers))
      (funcall org-pro-save-buffers))
    (let* ((pro (or project org-pro-current-project)))
       (when org-pro-use-git 
      (org-pro-git-update-project pro nil))))
#+END_SRC    
    
*** Switching between projects

#+BEGIN_SRC emacs-lisp :export code
(defun org-pro-magit (project)
  (magit-status (concat (org-pro-get-location project) (car project))))

(defun org-pro-location (project)
  (let ((loc (concat (org-pro-get-location project) (car project))))
    (find-file loc)))

(defun org-pro-timeline (project)
  (let (tbuf)
    (save-window-excursion
      (let ((index (org-pro-get-index project))
            (org-agenda-sticky nil)
            (bufname (concat "*" (car project) "-timeline*")))
        (if (not (file-exists-p index))
            (progn
              (switch-to-buffer bufname)
              (setq tbuf (get-buffer bufname))
              (toggle-read-only -1)
	      (erase-buffer)
              (insert "TIMELINE: Project index file does not exist yet"))
          (when (get-buffer bufname)
            (kill-buffer bufname))
          (find-file index)
          (org-timeline 'yeah)
          (rename-buffer bufname)
          (local-set-key [(return)] 'org-return)
          (setq tbuf (current-buffer)))))
    (switch-to-buffer tbuf)))

(defun org-pro-recent-org (project)
  (car (org-pro-list-files
	(concat (org-pro-get-location project) (car project)) "^[^\\.].*\\.org$" "time")))


(defun org-pro-todo (project)
  (let (tbuf)
    (save-window-excursion
      (let* ((location (concat (org-pro-get-location project) (car project)))
	     (org-files (org-pro-list-files location "^[^\\.].*\\.org$" nil))
	     (org-agenda-sticky t) ;; to enable multiple agenda buffers
	     (org-agenda-files org-files)
	     (bufname (concat "*" (car project) "-todo*")))
	(when (get-buffer bufname)
	  (kill-buffer bufname))
	(org-todo-list org-match)
	(rename-buffer bufname)
	(setq tbuf (current-buffer))))
    (switch-to-buffer tbuf)))

(defun org-pro-find-project (project pos)
  (org-pro-set-config project nil (or pos org-pro-config-cycle-pos 0)))

(defvar org-pro-human-readable-ext "^[^\\.].*\\.org\\|\\.[rR]\\|\\.tex\\|\\.txt\\|\\.el$" "Extensions of human readable files")

(defun org-pro-get (project el)
  (cdr (assoc el (cadr project))))

(defun org-pro-get-index (project)
"Extract the index file of PROJECT."
  (cdr (assoc "index" (cadr project))))


(defun org-pro-get-git (project)
  (or (cdr (assoc "git" (cadr project))) ""))

(defun org-pro-get-git-location (project)
  (or (cdr (assoc "git-location" (cadr project)))
      (concat (org-pro-get-location project) (car project))))

(defun org-pro-get-location (project)
  "Get the directory associated with PROJECT."
  (file-name-as-directory (cdr (assoc "location" (cadr project)))))
;;  (let ((loc (cdr (assoc "location" (cadr project)))))
;;                (if loc 
;;                                (concat (file-name-as-directory loc)
;;                                        (car project)))))

(defun org-pro-get-publish-directory (project)
  (cdr (assoc "publish-directory" (cadr project))))

(defun org-pro-get-category (project)
  (cdr (assoc "category" (cadr project))))

(defun org-pro-get-state (project)
  (cdr (assoc "state" (cadr project))))

(defvar org-pro-switch-always t
  "If nil 'org-pro-switch-to-project' will
 switch to current project unless the last command also was 'org-pro-switch-to-project'.
 Setting this variable to non-nil (the default) will force 'org-pro-switch-to-project'
 to always prompt for new project")

(defun org-pro-switch-config (&optional project)
  "Switch to the next window configuration (if any)."
  (interactive)
  (let* ((pro (or project org-pro-current-project))
	 (curpos (or org-pro-config-cycle-pos 0))
	 (config-list (org-pro-read-config-list
		       (org-pro-get-config pro))))
    (if (> (length config-list) (1+ org-pro-config-cycle-pos));; cycle-pos starts at 0
	(setq org-pro-config-cycle-pos (1+ org-pro-config-cycle-pos))
      (setq org-pro-config-cycle-pos 0))
    (org-pro-find-project pro org-pro-config-cycle-pos)))

(defun org-pro-switch (&optional arg)
  "If ARG switch project else switch config."
  (interactive "P")
  (if arg
      (org-pro-switch-to-project)
    (org-pro-switch-config)))

(defun org-pro-switch-to-project (&optional force)
  "Select project via 'org-pro-select-project', activate it
                                                   via 'org-pro-activate-project',  find the associated index file."
  (interactive "P")
  (let* ((curpro org-pro-current-project)
	 (change-maybe (or force
			   org-pro-switch-always
			   (not org-pro-current-project)))
	 (pro (if change-maybe (org-pro-select-project) curpro))
	 (stay (eq pro curpro)))
    (unless stay
      (org-pro-save-project curpro)
      (setq org-pro-config-cycle-pos 0)
      (org-pro-activate-project pro))
    (org-pro-find-project pro org-pro-config-cycle-pos)))

(defun org-pro-list-files (dir ext sort-by)
  (if (featurep 'file-list)
      (mapcar 'file-list-make-file-name
	      (file-list-sort-internal
	       (file-list-select-internal nil ext nil nil dir nil 'dont)
	       (or sort-by "time") nil t))
    (directory-files dir nil ext t)))
#+END_SRC

*** Find specific places in a project
#+BEGIN_SRC emacs-lisp :export code
(defun org-pro-goto-project (&optional project heading create prop-alist)
  (interactive)
  (let ((pro 
	 (or project
	     (car (org-pro-select-project)))))
    (when (and (not (string-equal pro "")) pro)
      (let* ((entry (assoc pro org-pro-project-alist))
	     (index (org-pro-get-index entry))
	     (head (or heading (read-string "Goto heading: "))))
	(if index
	    (find-file index)
	  (error (concat "Project " pro " does not have an index.")))
	(goto-char (point-min))
	(cond ((re-search-forward
		(format org-complex-heading-regexp-format (regexp-quote head))
		nil t))
	      (create
	       (insert "* " head "\n"))
	      (t (error (concat "Heading " head " not found in index file of " pro))))
        (org-show-entry)	
	(if prop-alist (mapcar (lambda (p)
				 (unless (org-entry-get nil (car p))
				   (org-set-property (car p) (car (cdr p))))) prop-alist))
	(re-search-forward ":END:" nil t)
	(end-of-line)
	(forward-line)
	(unless (looking-at "^[ \t]*$") (insert "\n"))))))


(defun org-pro-goto-project-workflow ()
  (interactive)
  (or (org-pro-goto-project nil "WorkFlow" 'create)))

(defun org-pro-goto-project-documents (&optional narrow)
  (interactive)
  (or (org-pro-goto-project nil "Documents" 'create '(("COLUMNS" "%20ITEM(Title) %GitStatus(Git Status) %50LastCommit(Last Commit) %8TODO(ToDo)")))
      (if narrow (org-pro-view t))))

(defun org-pro-goto-project-taskpool (&optional arg)
  (interactive)
  (if arg (org-store-link nil))
  (let* ((buf (current-buffer))
	 (pro (car (org-pro-select-project)))
	 ;;             (pro (ido-completing-read "Select project: " org-pro-project-alist))
	 (entry (assoc pro org-pro-project-alist))
	 (index (org-pro-get-index entry)))
    (if index
	(find-file index)
      (error (concat "Project " pro " does not have an index.")))
    (goto-char (point-min))
    (or (re-search-forward "^[*]+ TaskPool" nil t)
	(progn
	  (goto-char (point-max))
	  (insert "\n\n* TaskPool [0/0]\n")
	  (point))) 
    (org-end-of-line)
    ))
#+END_SRC     

#+RESULTS[0a54caeb762f25632636a46f3732ab516a0c9e87]:
: org-pro-goto-project-taskpool

** Capture: Adding information to projects
*** Choose a prefix
#+BEGIN_SRC  emacs-lisp :export code
(setq org-pro-capture-prefix "P")
(add-to-list 'org-capture-templates `(,org-pro-capture-prefix "Project management") 'append)
(defun org-pro-capture() 
  (interactive)
  (push (string-to-char org-pro-capture-prefix) unread-command-events)
  (call-interactively 'org-capture)
  )
#+END_SRC
*** Capturing links 
#+BEGIN_SRC  emacs-lisp :export code
(add-to-list 'org-capture-templates `(,(concat org-pro-capture-prefix "l") "Add link" plain 
 (function (lambda () (org-pro-goto-project nil "Links" 'yes))) "\n - %x%?") 'append)
#+END_SRC
*** Capturing tasks
#+BEGIN_SRC  emacs-lisp :export code
(add-to-list 'org-capture-templates `(,(concat org-pro-capture-prefix "t") "Add task" plain
  (function org-pro-goto-project-taskpool) "\n*** TODO %? \n:PROPERTIES:\n:CaptureDate: <%<%Y-%m-%d %a>>\n:END:") 'append)

(add-to-list 'org-capture-templates `(,(concat org-pro-capture-prefix "c") "Add checklist item" plain
  (function org-pro-goto-project-taskpool) "\n- [ ] %? \n:PROPERTIES:\n:CaptureDate: <%<%Y-%m-%d %a>>\n:END:") 'append)
#+END_SRC
*** Capturing notes
#+BEGIN_SRC  emacs-lisp :export code
(add-to-list 'org-capture-templates `(,(concat org-pro-capture-prefix "n") "Add note" plain
  (function org-pro-goto-project-workflow) "\n*** %? \n:PROPERTIES:\n:CaptureDate: <%<%Y-%m-%d %a>>\n:END:") 'append)
#+END_SRC
*** Capturing documents
#+BEGIN_SRC  emacs-lisp :export code
(add-to-list 'org-capture-templates
	     `(,(concat org-pro-capture-prefix "d") "Add document" plain
	       (function org-pro-goto-project-documents) "\n*** %? \n:PROPERTIES:\n:FileName: [[%(read-file-name \"Document file: \")]]\n:CaptureDate: %T\n:END:") 'append) 
#+END_SRC
** Export
*** Publishing

#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-export-subdirectory "export")
(defvar org-pro-public-directory "~/public_html/")
(defvar org-pro-public-server "" "Place on the web where pages are published.")

(defun org-pro-browse-this-file (&optional arg)
  "Browse the html version of the current file using `browse-url'. If
        prefix arg is given, then browse the corresponding file on the org-pro-public-server"
  (interactive "P")
  (let* ((bf (buffer-file-name (current-buffer)))
	 (html-file (if arg
			(concat (replace-regexp-in-string
				 (expand-file-name org-pro-public-directory)
				 org-pro-public-server-home
				 (file-name-sans-extension bf))
				".html")
		      (concat "file:///" (file-name-sans-extension bf) ".html"))))
    ;; fixme org-pro-browse-file-hook (e.g. to synchronize with public server)
    (message html-file)
    (browse-url html-file)))


;; (defvar org-pro-publish-subdirectory "public")
(require 'org-publish)
(defun org-pro-set-publish-alist ()
  (interactive)
  (let ((p-alist org-pro-project-alist))
    (while p-alist
      (let* ((pro  (car p-alist))
	     (nickname (car pro))
	     (base-directory (concat (org-pro-get-location pro) (car pro)))
	     (export-directory
	      (concat base-directory "/"
		      org-pro-export-subdirectory))
	     (public-directory
	      (or (org-pro-get-publish-directory pro)
		  (concat (file-name-as-directory org-pro-public-directory)
			  nickname))))
	;;(replace-regexp-in-string org-pro-public-directory (getenv "HOME") (expand-file-name export-directory))))
	(add-to-list 'org-publish-project-alist
		     `(,(concat nickname "-export")
		       :base-directory
		       ,base-directory
		       :base-extension "org"
		       :publishing-directory
		       ,base-directory
		       :headline-levels 4
		       :auto-preamble t
		       :recursive t
		       :publishing-function
		       org-publish-org-to-html))
	(add-to-list 'org-publish-project-alist
		     `(,(concat nickname "-copy")
		       :base-directory
		       ,export-directory
		       :base-extension
		       "html\\|png\\|jpg\\|org\\|pdf"
		       :publishing-directory
		       ,public-directory
		       :recursive t
		       :publishing-function
		       org-publish-attachment))
	(add-to-list 'org-publish-project-alist
		     `(,nickname
		       :components (,(concat nickname "-export") ,(concat nickname "-copy")))))
      (setq p-alist (cdr p-alist)))))
#+END_SRC   

** The end
#+BEGIN_SRC emacs-lisp :export code
(provide 'org-project-manager)
#+END_SRC
