# Project-Manager mode
* Header 							   :noexport:
:PROPERTIES:
#+TITLE: An emacs-org project manager for applied statisticians
#+EMAIL: tag@biostat.ku.dk
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc author:nil
#+LaTeX_HEADER:\usepackage{authblk}
#+LaTeX_HEADER:\usepackage{natbib}
#+LaTeX_HEADER:\usepackage[T1]{fontenc}
#+LaTeX_HEADER:\renewcommand*\familydefault{\sfdefault}
#+LaTeX_HEADER:\usepackage[table,usenames,dvipsnames]{xcolor}
#+LaTeX_HEADER:\definecolor{lightGray}{gray}{0.98}
#+LaTeX_HEADER:\definecolor{medioGray}{gray}{0.83}
#+LaTeX_HEADER:\rowcolors{1}{medioGray}{lightGray}
#+LaTeX_HEADER:\usepackage{attachfile}
#+LaTeX_HEADER:\usepackage{array}
#+LaTeX_HEADER:\author{Thomas Alexander Gerds}
#+LaTeX_HEADER:\affil{Department of Biostatistics, University of Copenhagen, Denmark}
#+LaTeX_HEADER:\author{Klaus K\"ahler Holst}
#+LaTeX_HEADER:\affil{Department of Biostatistics, University of Copenhagen, Denmark}
#+LaTeX_HEADER:\author{Jochen Knaus}
#+LaTeX_HEADER:\affil{Department of Medical Biometrie and Medical Informatics, University of Freiburg, Freiburg, Germany}
#+LaTeX_HEADER:\newcommand{\sfootnote}[1]{\renewcommand{\thefootnote}{\fnsymbol{footnote}}\footnote{#1}\setcounter{footnote}{0}\renewcommand{\thefootnote}{\arabic{foot note}}}
#+LaTeX_HEADER:\makeatletter\def\blfootnote{\xdef\@thefnmark{}\@footnotetext}\makeatother
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LaTeX_HEADER \itemsep2pt
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)
#+LaTeX_HEADER: \usepackage{color}
#+LATEX_HEADER: \lstset{
#+LATEX_HEADER: keywordstyle=\color{blue},
#+LATEX_HEADER: commentstyle=\color{red},
#+LATEX_HEADER: stringstyle=\color[rgb]{0,.5,0},
#+LATEX_HEADER: basicstyle=\ttfamily\small,
#+LATEX_HEADER: columns=fullflexible,
#+LATEX_HEADER: breaklines=true,        % sets automatic line breaking
#+LATEX_HEADER: breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
#+LATEX_HEADER: numbers=left,
#+LATEX_HEADER: numberstyle=\ttfamily\tiny\color{gray},
#+LATEX_HEADER: stepnumber=1,
#+LATEX_HEADER: numbersep=10pt,
#+LATEX_HEADER: backgroundcolor=\color{white},
#+LATEX_HEADER: tabsize=4,
#+LATEX_HEADER: showspaces=false,
#+LATEX_HEADER: showstringspaces=false,
#+LATEX_HEADER: xleftmargin=.23in,
#+LATEX_HEADER: frame=single,
#+LATEX_HEADER: basewidth={0.5em,0.4em}
#+LATEX_HEADER: }
#+PROPERTY: session *R* 
#+PROPERTY: cache yes
#+PROPERTY: tangle yes
#+PROPERTY: colnames yes
:END:
  
* Introduction 
  
  This document simulaneously describes and defines a project manager
  for applied statistical workflows based on the fabulous and popular
  emacs =org-mode=. Really it describes and automates one out of many
  possibilities to customize =org-mode=.
  
** Getting started
   
   The first thing to do is to define some new projects. Obviously, you
   would rather read in your existing projects. But stay cool and read on
   until this is explained below.
   
*** The project manager file
    
    
#+BEGIN_SRC emacs-lisp :exports none :eval never :tangle no
  (setq org-pro-file "~/projects/manager.org")
  (find-file org-pro-file)
#+END_SRC

**** What is a project?
    
     As in real life an org-pro project can be many different things. The
     prototype project consists of a /location/, that is a directory on
     your computer, and an index file. (Actually, only one of /index/ and
     /location/ is required.)
     
**** How to define a project?
     
     Projects are defined in the file /org-pro-file/
     (yes-you-need-to-create-this-file) in the following format.
     
#+BEGIN_SRC org :tangle no
 * Cat 1
 ** Subcat 1
 *** Subsubcat 1
 **** Learning org (My first org-pro project)
 :PROPERTIES:
 :NICKNAME: howto-org
 :INDEX:  ~/knowhow/howto.org
 :LOCATION: ~/knowhow/
 :OTHERS: justme
 :END:     
 **** Test org-pro
 :PROPERTIES:
 :NICKNAME: howto-org
 :INDEX:  ~/knowhow/howto.org
 :LOCATION: ~/knowhow/
 :OTHERS: Alphonse Quack
 :END:     
#+END_SRC

** Git support
*** Requirements

You need to install the program git.

*** Git hub

To do push changes to a github repository it is useful to set up git  
https://help.github.com/articles/set-up-git
and to be free of typing the username and password when doing "git push".

If you use the SSH repo URL instead, SSH keys are used for
authentication. This guide offers help generating and using an SSH key
pair:  https://help.github.com/articles/generating-ssh-keys

* Project manager code :noexport:
** Dependencies

#+BEGIN_SRC emacs-lisp :export code
(require 'org)  
(require 'deft)
(require 'winner)
(require 'ido)
;; (require 'workgroups)
#+END_SRC

** Setup and maintenance
*** The project manager file   
#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-default-directory (file-name-as-directory org-directory) "A place for new projects.")
(defvar org-pro-file (concat
                               (file-name-as-directory org-directory)
                                         "Projects.org")
  "Where the org-pro defines the projects. See the manual
for structure and syntax.")
#+END_SRC

#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-project-level 4
"Subheading level at which projects are defined in `org-pro-file'.")
#+END_SRC

The project manager is in org-mode (major-mode). To change specific
keystrokes only in this file, the current solution is to put
a minor-mode on top of it.
    
#+BEGIN_SRC emacs-lisp :export code
  (defvar org-pro-minor-mode nil)
    (make-variable-buffer-local 'org-pro-minor-mode)
  (defvar org-pro-minor-mode-map (make-sparse-keymap)
      "Keymap used for `org-pro-minor-mode' commands.")
    (or (assq 'org-pro-minor-mode minor-mode-map-alist)
        (setq minor-mode-map-alist
              (append minor-mode-map-alist
                      (list (cons 'org-pro-minor-mode org-pro-minor-mode-map)))))
    (or (assq 'org-pro-minor-mode minor-mode-alist)
        (setq minor-mode-alist
              (cons '(org-pro-minor-mode " Project") minor-mode-alist)))
  (defun org-pro-minor-mode (&optional arg)
      "A minor mode for using org Project Manager."
      (interactive "P")
      ;; (make-variable-buffer-local 'hippie-expand-try-functions-list)
      (setq org-pro-minor-mode
            (not (or (and (null arg) org-pro-minor-mode)
                     (<= (prefix-numeric-value arg) 0))))
      (add-hook 'after-save-hook 'org-pro-refresh nil 'local))
    (define-key org-pro-minor-mode-map [(meta return)] 'org-pro-return)
    (define-key org-pro-minor-mode-map [(meta n)] 'org-pro-next-project)
    (define-key org-pro-minor-mode-map [(meta p)] 'org-pro-previous-project)
    (add-hook 'find-file-hooks 
              (lambda ()
                (let ((file (buffer-file-name)))
                  (when (and file (equal file (expand-file-name org-pro-file)))
                    (org-pro-minor-mode)))))
#+END_SRC
   
*** Dynamically updating lists 
    
#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-project-alist nil
  "Alist of projects associating the nickname of the project
              with information like the location of the project, the index file, collaborators, category, publishing-directory, etc.")

(defvar org-pro-current-project nil "The currently selected project.")

(defun org-pro-entry-get  (pom property &optional inherit literal-nil)
  (let ((prop (org-entry-get pom property inherit literal-nil)))
    (if (stringp prop) (replace-in-string prop "[ \t]+$" ""))))

(defun org-pro-parse-projects (&optional all)
  "Parse file 'project-manager' and update 'org-pro-project-alist'"
  (interactive)
  (save-excursion
    (setq org-pro-project-alist nil)
    (set-buffer (find-file-noselect org-pro-file))
    (save-buffer)
    (goto-char (point-min))
    (while (org-pro-forward-project)
      (let* ((loc (or (org-pro-entry-get nil "LOCATION" 'inherit) org-pro-default-directory))
	     (category (org-pro-entry-get nil "CATEGORY" 'inherit))
	     (others (org-pro-entry-get nil "OTHERS" nil))
	     (publish-dir (org-pro-entry-get nil "PUBLISH" 'inherit))
	     (name (or (org-pro-entry-get nil "NICKNAME" nil)
		       (nth 4 (org-heading-components))))
	     (git (org-pro-entry-get nil "GIT" 'inherit))
	     (config (org-pro-entry-get nil "config" 'inherit))
	     (index (or (org-pro-entry-get nil "INDEX" nil)
			(let ((default-org-home
				(concat (file-name-as-directory loc)
					name
					org-pro-org-location)))
			  ;; (make-directory default-org-home t)
			  (concat (file-name-as-directory default-org-home) name ".org")))))
	(unless (file-name-absolute-p index)
	  (setq index
		(expand-file-name (concat (file-name-as-directory loc) name "/" index))))
	(add-to-list 'org-pro-project-alist
		     (list name
			   (list (cons "location"  loc)
				 (cons "index" index)
				 (cons "category" category)
				 (cons "others" others)
				 (cons "git" git)
				 (cons "config" config)
				 (cons "publish-directory" publish-dir))))))
    org-pro-project-alist))

(defvar org-pro-project-categories nil
  "List of categories for sorting projects.")

(defun org-pro-get-buffer-props (property)
  "Get a table of all values of PROPERTY used in the buffer, for completion."
  (let (props)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward (concat ":" property ":") nil t)
	(add-to-list 'props (list
			     (org-entry-get
			      nil property nil)))))
    props))

(defun org-pro-parse-categories ()
  (interactive)
  (set-buffer (find-file-noselect org-pro-file))
  (setq org-pro-project-categories
	(reverse (org-pro-get-buffer-props "CATEGORY"))))

(defun org-pro-refresh ()
  "Parses the categories and projects in file `org-pro' and also
       updates the currently selected project."
  (interactive)
  (org-pro-parse-categories)
  (org-pro-parse-projects)
  (when org-pro-current-project
    (setq org-pro-current-project
	  (assoc (car org-pro-current-project) org-pro-project-alist))))

#+END_SRC

*** Lists of project-index and project-org files 

#+BEGIN_SRC emacs-lisp :export code
(defun org-pro-index-list (&optional category extension not-exist-ok update)
 "Return a list of project specific indexes.
Projects are filtered by CATEGORY unless CATEGORY is nil.
Only existing files are returned unless NOT-EXIST-OK is non-nil.
Only files ending on EXTENSION are returned unless EXTENSION is nil.
If UPDATE is non-nil first parse the file org-pro."
 (interactive "P")
 (if update
 (org-pro-refresh))
 (delete-dups (delq nil (mapcar '(lambda (x)
 (let ((f (org-pro-get-index x)))
       (when (and (or not-exist-ok (file-exists-p f))
                (or (not extension)
                    (string= extension (file-name-extension f))))
                     f)))
  (if category
      (delq nil (mapcar '(lambda (p) (if (string= category (org-pro-get-category p))
                           p))
                        org-pro-project-alist))
  org-pro-project-alist)))))
#+END_SRC

*** The profile of a single project

#+BEGIN_SRC emacs-lisp :export code   
(defvar org-pro-org-location "/"
    "Relative to the project location this defines
  the path to the index file of a project. If set to
  '/org/' then the index file will be placed
  in a subdirectory 'org' of the project directory.")
#+END_SRC

#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-default-category "Unsorted" "Category for new projects.")
;; (setq org-refile-targets (quote ((org-pro :maxlevel . 3) (nil :maxlevel . 2))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :export code
(defun org-pro-set-nickname ()
  (interactive)
  (org-set-property
   "NICKNAME"
   (read-string "NickName for project: "
		(nth 4 (org-heading-components)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :export code
(defun org-pro-set-others ()
  (interactive)
  (let* ((pro (assoc (org-pro-project-at-point t)
    org-pro-project-alist))
         (others (cdr (assoc "others" (cadr pro))))
         (init (if others (concat others ", ") "")))
       ;; (org-entry-get nil "others")
(if pro
     (org-set-property
     "others"
   (replace-in-string
    (read-string (concat "Set collaborators for " (car pro) ": ") init)
    "[,\t ]+$" "")))))


(defun org-pro-fix-others ()
(interactive)
(goto-char (point-min))
(while (org-pro-forward-project)
  (org-pro-set-others)))
#+END_SRC

** Adding new projects
**** The structure template approach
     CLOSED: [2012-09-14 Fri 09:01]
#+BEGIN_SRC emacs-lisp :export code     
(add-to-list 'org-structure-template-alist
 '("P" "**** ACTIVE %?:PROPERTIES:\n:NICKNAME:\n:OTHERS:\n:CaptureDate:\n:END:"))
#+END_SRC

**** COMMENT The interactive approach     
     
#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-default-content "" "Initial contents of org project index file.")
(defvar org-pro-project-subdirectories nil)


(defun org-pro-create-project (&optional project ask)
  "Create the index file, the project directory, and subdirectories if
                  'org-pro-project-subdirectories' is set."
  (interactive)
  (let ((pro (assoc project org-pro-project-alist)))
    (when pro
      (let ((dir (concat (org-pro-get-location pro) (car pro)))
	    (index (org-pro-get-index pro)))
	(unless (or (not dir) (file-exists-p dir) (not (and ask (y-or-n-p (concat "Create directory (and default sub-directories) " dir "? ")))))
	  (make-directory dir)
	  (loop for subdir in org-pro-project-subdirectories
		do (unless (file-exists-p subdir) (make-directory (concat path subdir) t))))
	(find-file org-pro-file)
	(goto-char (point-min))
	(re-search-forward (concat (make-string org-pro-project-level (string-to-char "*")) ".*" (car pro)) nil )))))
;;          (when (and index (not (file-exists-p index)))
;;            (unless (file-exists-p (file-name-directory index))
;;              (make-directory (file-name-directory index) t))
;;            (find-file index))))))
;; (append-to-file org-pro-default-content nil index)
;; )))

(defun org-pro-show-properties ()
  (let ((pop-up-windows t)
	(obuf (current-buffer))
	(pbuf (get-buffer "*Org project manager properties*")))
    (set-buffer pbuf)
    (erase-buffer)
    (insert "Current project categories:\n\n")
    (mapcar '(lambda (x) (if (car x) (insert (car x) ", "))) org-pro-project-categories)
    (delete-backward-char 2)
    (insert "\n\n")
    (pop-to-buffer pbuf)
    (pop-to-buffer obuf)))

(defun org-pro-new-project (&optional nickname category)
  "Create a new project. Prompt for CATEGORY and NICKNAME if necessary.
This function modifies the 'org-pro' and creates and visits the index file of the new project.
Thus, to undo all this you may want to call 'org-pro-delete-project'. 
" 
  (interactive)
  (org-pro-refresh)
  (let* ((nickname (or nickname (read-string "Project name (short) ")))
	 category)
    ;; check if nickname exists 
    (while (assoc nickname org-pro-project-alist)
      (setq nickname
	    (read-string (concat "Project " nickname " exists. Please choose a different name (C-g to exit): "))))
    (setq category (or category (completing-read "Category: " (org-pro-parse-categories) nil nil)))
    ;; a local capture command places the new project
    (let ((org-capture-templates
	   `(("p" "Project" plain
	      (file+headline org-pro-file ,category)
	      ,(concat (make-string org-pro-project-level (string-to-char "*"))
		       " ACTIVE " nickname "%?\n:PROPERTIES:\n:NICKNAME: "
		       nickname
		       "\n:LOCATION: \n:CATEGORY: " category "\n:INDEX: \n:GIT: \n:OTHERS: \n:END:\n"))))
	  (org-capture-bookmark nil))
      (add-hook 'org-capture-mode-hook '(lambda () (define-key org-capture-mode-map [(tab)] 'org-pro-complete-property)) nil 'local)
      (add-hook 'org-capture-after-finalize-hook `(lambda () (org-pro-create-project ,nickname 'ask)) nil 'local)
      ;;(add-hook 'org-capture-mode-hook 'org-pro-show-properties nil 'local)
      (org-capture nil "p")
      )))
(defun org-pro-complete-property ()
  (interactive)
  (let ((curprop (save-excursion (beginning-of-line) (looking-at ".*:\\(.*\\):") (org-match-string-no-properties 1))))
    (cond ((string= (downcase curprop) "index")
	   (insert (read-file-name (concat "Set " curprop ": "))))
	  ((string= (downcase curprop) "location")
	   (insert (read-directory-name (concat "Set " curprop ": ")))))))

(defun org-pro-delete-project (&optional project)
  ;;                                  (interactive)
  (let* ((pro (or project org-pro-select-project))
	 (dir (concat (org-pro-get-location pro) (car pro)))
	 (git (org-pro-get-git pro))
	 (index (org-pro-get-index pro)))
    (pop-to-buffer "*Org-project-files*")
    (erase-buffer)
    (insert index "\n" dir "\n" git "\n")
    (when (yes-or-no-p (concat "Really remove project " pro "?")))))
#+END_SRC

** The project manager
#+BEGIN_SRC emacs-lisp  :export code
(defun org-pro-goto-project-manager ()
    (interactive)
    (find-file org-pro-file))
  
(defun org-pro-project-at-point (&optional noerror)
    "Check if point is at project heading and return the project,
      i.e. its entry from the 'org-pro-project-alist'.
      Otherwise return error or nil if NOERROR is non-nil. "
    (interactive)
      ;; (org-back-to-heading)
    (if (or (org-before-first-heading-p)
            (not (org-at-heading-p))
            (not (= org-pro-project-level
                    (- (match-end 0) (match-beginning 0) 1))))
        (if noerror nil
          (error "No project at point"))
      (or (org-entry-get nil "NICKNAME")
          (progn (org-pro-set-nickname)
                 (save-buffer) ;; to update the project-alist
                 (org-entry-get nil "NICKNAME")))))
  
  
(defun org-pro-return ()
    (interactive)
    (let* ((pro (assoc (org-pro-project-at-point)
                       org-pro-project-alist)))
      (delete-other-windows)
            (split-window-horizontally 25)
            (other-window 1)
            (find-file (org-pro-get-index pro))
            (split-window-vertically 13)
            (switch-to-buffer "*Current project*")
            (erase-buffer)
            (insert (car pro) "\n------------------------------\n")
            (mapc (lambda (x) (insert (car x) ": " (if (cdr x) (cdr x) "")  "\n")) (cadr pro))
            (other-window 1)))
        
(defun org-pro-forward-project ()
      (interactive)
        (re-search-forward
         (format "^\\*\\{%d\\} " org-pro-project-level) nil t))
        
(defun org-pro-backward-project ()
        (interactive)
        (re-search-backward
         (format "^\\*\\{%d\\} " org-pro-project-level) nil t))
        
(defun org-pro-next-project (arg)
        (interactive  "p")
        (org-pro-forward-project)
        (org-pro-return))
        
(defun org-pro-previous-project (arg)
        (interactive  "p")
        (org-pro-backward-project)
        (org-pro-return))
#+END_SRC

** Capture: Adding information to projects
*** Choose a prefix
#+BEGIN_SRC  emacs-lisp :export code
(setq org-pro-capture-prefix "P")
(add-to-list 'org-capture-templates `(,org-pro-capture-prefix "Project management"))
#+END_SRC
*** Capturing links 
#+BEGIN_SRC  emacs-lisp :export code
(add-to-list 'org-capture-templates `(,(concat org-pro-capture-prefix "l") "Add a link" plain 
 (function (lambda () (org-pro-goto-project nil "Links" 'yes))) "\n - %x%?"))
#+END_SRC
*** Capturing tasks
#+BEGIN_SRC  emacs-lisp :export code
(add-to-list 'org-capture-templates `(,(concat org-pro-capture-prefix "t") "Add a task" plain
  (function org-pro-goto-project-taskpool) "\n*** TODO %? \n:PROPERTIES:\n:CaptureDate: <%<%Y-%m-%d %a>>\n:END:"))
#+END_SRC
*** Capturing notes
#+BEGIN_SRC  emacs-lisp :export code
(add-to-list 'org-capture-templates `(,(concat org-pro-capture-prefix "n") "Add a note" plain
  (function org-pro-goto-project-workflow) "\n*** %? \n:PROPERTIES:\n:CaptureDate: <%<%Y-%m-%d %a>>\n:END:"))
#+END_SRC
*** Capturing documents
#+BEGIN_SRC  emacs-lisp :export code
;;(add-to-list 'org-capture-templates `(,(concat org-pro-capture-prefix "n") "Add a document" plain
;;  (function org-pro-goto-project-workflow) "\n*** %? \n:PROPERTIES:\n:CaptureDate: <%<%Y-%m-%d %a>>\n:END:"))
#+END_SRC

** COMMENT Git control
   
#+BEGIN_SRC emacs-lisp :export code 

(defvar org-pro-use-git t "Whether to use git to backup projects. Set to nil to completely disable git.
If non-nil, git is controlled on per project basis using properties set in `org-pro'.")

(defun org-pro-git-p (dir)
   "Test if directory DIR is under git control."
   (eq 0 (shell-command (concat "cd " dir ";git rev-parse --is-inside-work-tree "))))
          
(defun org-pro-git-init-directory (dir)
          "Put directory DIR under git control."
           (if (org-pro-git-p dir)
            (message (concat "Directory " dir " is under git control."))
           (shell-command (concat "cd " dir "; git init"))
           (append-to-file org-pro-git-ignore nil (concat dir ".gitignore"))))
          
(defun org-pro-git-update-directory (dir silent)
        "Put directory DIR under git control."
      (let* ((necessary (not (string-match "nothing to commit" (shell-command-to-string  (concat "cd " dir "; git status")))))
               (doit (when necessary (or silent (y-or-n-p (concat "Update git at " dir "? ")))))
               (message (when doit (if silent "silent update" (read-string "Git commit message: ")))))
          (if doit
              (shell-command (concat "cd " dir "; git add -u;git commit -m \"" message "\"")))))
      
        
(defun org-pro-git-push-directory (dir silent)
          "Put directory DIR under git control."
          (let* ((status (shell-command-to-string  (concat "cd " dir "; git status")))
                 (necessary (string-match "Your branch is ahead .*\n" status))
                 (doit (or silent (y-or-n-p (concat "Your branch is ahead ... push git at " dir "? ")))))
            (if doit
                (shell-command (concat "cd " dir "; git push")))))
              
(defun org-pro-git-update-project (project before)
    "Check if project needs to be put under git control and update.
      If BEFORE is set then either initialize or pull. Otherwise, add, commit and/or push.
      "
    (let* ((git-control (downcase (org-pro-get-git project))))
      (unless (or (string= git-control "") (string-match "no\\|never\\|nil" git-control))
        (let ((silent-p (string= git-control "silent"))
              (dir (org-pro-get-git-location project)))
          (when (file-exists-p dir)
            (if before
                (progn
                ;; activating project
                (unless (or (org-pro-git-p dir) (string-match "no" git-control) (string= "" git-control))
                  (when (or silent-p
                            (y-or-n-p (concat "Initialize git control at " dir "?")))
                    (org-pro-git-init-directory dir)))
                  (when (and (string-match "pull" git-control)
                             (or silent-p (y-or-n-p (concat "Run this command: \"git pull\" at " dir "? "))))
                    (shell-command (concat "cd " dir "; git pull"))))
              ;; deactivating project
              (when (and (org-pro-git-p dir)
                         (string-match "yes\\|silent" git-control))
                (org-pro-git-update-directory dir silent-p)
                (when (string-match "push" git-control)
                  (org-pro-git-push-directory dir silent-p)
                  ))))))))
      
(defvar org-pro-git-ignore "*
!*.org" "What files to include or not include.
Default is * meaning ignore all files and
 !*.org meaning except for org files.")
#+END_SRC   

** Window configuration

It may be counterintuitive, but saving a window configuration is not
so easy. One reason is that unsaved, temporary stuff like
file-unrelated buffers cannot be restored. Also, the dimensions of
frames and windows depend on the current screen and most people will
at least occasionally work on different screens.

What we could do is restore from saved files and certain
file-unrelated buffers, as for example a buffer showing a shell. We
can also save the number of windows and the horizontal and vertical
splits in the current frame. 

#+BEGIN_SRC  emacs-lisp :export code
(setq org-pro-config "INDEX / LOCATION | TIMELINE / TODO")
;; could be 
;; (setq org-pro-config "recent.org / *R* | TODO")
(setq org-pro-config-action-alist '(("INDEX" . org-pro-find-index)
				    ("TODO" . org-pro-todo)
				    ("TIMELINE" . org-pro-timeline)
				    ("LOCATION" . org-pro-location)
				    ("magit" . org-pro-magit)
				    ("recent.org" . org-pro-recent-org)
				    ("*shell*" . (lambda (project) (if (get-buffer "*shell*") (switch-to-buffer "*shell*") (shell))))
				    ("*R*" . org-pro-find-R-function)))

(defvar org-pro-find-R-function
  "Function used to find *R*"
  (lambda (project) (if (get-buffer "*R*") (switch-to-buffer "*R*") (R))))

(defun org-pro-find-index (project)
  (let* ((index (org-pro-get-index project)))
    (unless (file-exists-p index)
      (make-directory (file-name-directory index) 'with-parents))
    (find-file index)))

(defun org-pro-find-thing (thing project)
  (let* ((case-fold-search t)
         (action (cdr (assoc (replace-in-string (car thing) "^[ \t\n]+\\|[ \t\n]+$" "")
			     org-pro-config-action-alist))))
    (cond ((functionp action) (funcall action project))
          ((and (car thing) (file-name-directory (car thing)))
           (find-file (expand-file-name
		       (car thing) (concat (org-pro-get-location project) (car project)))))
          (t (switch-to-buffer (car thing))))))

(defun org-pro-read-config-list (string)
  ;; return a list of lists with vertical splits 
  ;; where each element can have horizontal splits
  (split-string string "[ \t]+:[ \t]+"))

(defun org-pro-read-config (config &optional pos)
  ;; return a list with horizontal splits 
  ;; where each element can have vertical splits
  (let* ((vlist (split-string config "[ \t]+|[ \t]+"))
	 (hlist (mapcar '(lambda (x) (split-string x "[ \t]+/[ \t]+")) vlist)))
    hlist))


(defun org-pro-save-config (&optional config project)
  (interactive)
  (let ((conf (or config (org-pro-current-config)))
        (pro (or project org-pro-current-project (org-pro-select-project))))
       (find-file-other-window (concat (org-pro-get-location pro) (car pro) "/.org-pro-window-config"))
       (goto-char (point-max))
       (unless (looking-at "^$") (insert "\n"))
       (insert conf)
 (save-buffer)))

(defun org-pro-current-config ()
  (let* ((windata (winner-win-data))
         config
         prev-row)
    (while windata
      (let* ((buf (cdr (car windata)))
	     (pos (car (car windata)))
;;	     (col (nth 0 pos))
	     (row (nth 1 pos))
	     (thing
	      (cond 
               ((buffer-file-name buf)
                (replace-in-string (buffer-file-name buf) (getenv "HOME") "~"))
		  ;; (get-buffer-process buf)
		(t (buffer-name buf)))))
	(setq config (concat config (when prev-row (if (< prev-row row) " / " " | ")) thing))
	(setq windata (cdr windata))
	(setq prev-row row)))
    config))

;;(defun org-pro-set-config-1 (&optional project config pos)
;;  (interactive)
;;  (let* ((pro (or project org-pro-current-project (org-pro-select-project)))
;;	 (conf (or config (org-pro-get-config pro) org-pro-config))
;;	 (pos (or pos org-pro-config-cycle-pos 0))
;;	 (window-config (org-pro-read-config (nth pos (org-pro-read-config-list conf))))
;;	 swindow)
;;    (delete-other-windows)
;;    ;; save current window 
;;    (setq swindow (selected-window))
;;    (while window-config
;;      (let ((el (car window-config)))
;;	(while el
;;	  (org-pro-find-thing el pro)
;;	  (setq el (cdr el))
;;	  (when el (split-window-vertically) (other-window 1)))
;;	(setq window-config (cdr window-config))
;;	(when window-config (split-window-horizontally) (other-window 1))))
;;    (select-window swindow)))

(defvar org-pro-config-cycle-pos 0 "Position in the current window configuration cycle. Starts at 0.")


(defun org-pro-get-config (project)
  (let* ((config (or org-pro-config "INDEX"))
         (config-file  (concat (org-pro-get-location project) (car project) "/.org-pro-window-config"))
	 (filed-config (when (file-exists-p config-file)
		   (save-window-excursion
		     (find-file config-file)
		     (replace-in-string (buffer-string) "\n" " : "))))
	 (prop-config (cdr (assoc "config" (cadr project)))))
    (if (not config)
       (setq config prop-config)
    (when filed-config
      (setq config (concat config " : " filed-config)))
    (when prop-config
      (setq config (concat config " : " prop-config)))
    config)))

(defun org-pro-set-config (&optional project config pos)
  (interactive)
  (let* ((pro (or project org-pro-current-project (org-pro-select-project)))
	 (conf (or config (org-pro-get-config pro) org-pro-config))
	 (pos (or pos org-pro-config-cycle-pos 0))
	 (window-config (org-pro-read-config (nth pos (org-pro-read-config-list conf))))
	 (ncolumns (length window-config))
	 top-windows)
    (delete-other-windows)
    (setq top-windows (list (selected-window)))
    (loop for n from 1 to (- ncolumns 1) do
	  (split-window-horizontally)
	  (other-window 1)
	  (setq top-windows (append top-windows (list (selected-window)))))
    (loop for n from 0 to (- ncolumns 1) do 
	  (select-window (nth n top-windows))
	  (let ((el (nth n window-config)))
	    (while el
	      (org-pro-find-thing el pro)
	      (setq el (cdr el))
	      (when el (split-window-vertically) (other-window 1)))))
    (select-window (nth 0 top-windows))))
#+END_SRC

** Hacking deft

#+BEGIN_SRC  emacs-lisp :export code
;; Hack to search project index files
;; and to start new projects via deft 
(defun deft-local-setup ()
  ;; (kill-all-local-variables)
  (make-variable-buffer-local 'deft-buffer)
  (make-variable-buffer-local 'deft-directory)
  (make-variable-buffer-local 'deft-current-files)
  (make-variable-buffer-local 'deft-all-files)
  (make-variable-buffer-local 'deft-filter-regexp)
  (make-variable-buffer-local 'deft-find-all-files-function)
  (make-variable-buffer-local 'deft-new-file-function)
  (make-variable-buffer-local 'deft-filter-match-file-function)
  (make-variable-buffer-local 'deft-hash-mtimes)
  (make-variable-buffer-local 'deft-hash-contents)
  (make-variable-buffer-local 'deft-hash-titles)
  (make-variable-buffer-local 'deft-hash-summaries)
  (setq truncate-lines t)
  (setq buffer-read-only t)
  (setq default-directory deft-directory)
  (use-local-map deft-mode-map)
  (deft-cache-initialize)
  (deft-cache-update-all)
  (deft-filter-initialize)
  (setq major-mode 'deft-mode)
  (deft-set-mode-name)
  (deft-buffer-setup) ;; calls deft-refresh
  (when (> deft-auto-save-interval 0)
    (run-with-idle-timer deft-auto-save-interval t 'deft-auto-save))
  (run-mode-hooks 'deft-mode-hook))

(defun deft-local-mode ()
  ;; (kill-all-local-variables)
  (setq truncate-lines t)
  (setq buffer-read-only t)
  (setq default-directory deft-directory)
  (use-local-map deft-mode-map)
  (deft-cache-initialize)
  (deft-cache-update-all)
  (deft-filter-initialize)
  (setq major-mode 'deft-mode)
  (deft-set-mode-name)
  (deft-buffer-setup) ;; calls deft-refresh
  (when (> deft-auto-save-interval 0)
    (run-with-idle-timer deft-auto-save-interval t 'deft-auto-save))
  (run-mode-hooks 'deft-mode-hook))

(defvar deft-new-file-function 'deft-new-file-local)
(defvar deft-find-all-files-function 'deft-find-all-files-local)
(defvar deft-filter-match-file-function 'deft-filter-match-file-local)

(defun deft-filter-match-file (file &optional batch)
  (funcall deft-filter-match-file-function file batch))
(defun deft-find-all-files ()
  (funcall deft-find-all-files-function))
(defun deft-new-file ()
  (funcall deft-new-file-function))

;; copy of original deft-find-all-files
(defun deft-find-all-files-local (&optional dir)
  "Return a list of all files in the Deft directory."
  (let ((dir (or dir deft-directory)))
    (if (file-exists-p dir)
	(let (files result)
	  ;; List all files
	  (setq files
		(directory-files dir t
				 (concat "\." deft-extension "$") t))
	  ;; Filter out files that are not readable or are directories
	  (dolist (file files)
	    (when (and (file-readable-p file)
		       (not (file-directory-p file)))
	      (setq result (cons file result))))
	  result))))

;; copy of original deft-filter-match-file
(defun deft-filter-match-file-local (file &optional batch)
  "Return FILE if FILE matches the current filter regexp."
  (let ((dfr deft-filter-regexp)
        (dhc deft-hash-contents)
        (dhs deft-hash-summaries)
        (dht deft-hash-titles)
        (dhm deft-hash-mtimes))
    (with-temp-buffer
      (make-variable-buffer-local 'deft-filter-regexp)
      (make-variable-buffer-local 'deft-hash-summaries)
      (make-variable-buffer-local 'deft-hash-titles)
      (make-variable-buffer-local 'deft-hash-contents)
      (make-variable-buffer-local 'deft-hash-mtimes)
      (setq deft-filter-regexp dfr
            deft-hash-contents  dhc 
	    deft-hash-summaries dhs
	    deft-hash-titles dht
	    deft-hash-mtimes dhm)
      (setq deft-filter-regexp dfr)
      (insert file)
      (insert (deft-file-title file))
      (insert (deft-file-contents file))
      (if batch
	  (if (every (lambda (filter)
		       (goto-char (point-min))
		       (deft-search-forward filter))
		     deft-filter-regexp)
	      file)
	(goto-char (point-min))
	(if (deft-search-forward (car deft-filter-regexp))
	    file)))))


;; copy of original def-new-file
(defun deft-new-file-local ()
  "Create a new file quickly, with an automatically generated filename
or the filter string if non-nil and deft-use-filename-as-title is set.
If the filter string is non-nil and title is not from filename,
use it as the title."
  (interactive)
  (let (filename)
    (if (and deft-use-filename-as-title deft-filter-regexp)
	(setq filename (concat (file-name-as-directory deft-directory) (deft-whole-filter-regexp) "." deft-extension))
      (let (fmt counter temp-buffer)
	(setq counter 0)
	(setq fmt (concat "deft-%d." deft-extension))
	(setq filename (concat (file-name-as-directory deft-directory)
			       (format fmt counter)))
	(while (or (file-exists-p filename)
		   (get-file-buffer filename))
	  (setq counter (1+ counter))
	  (setq filename (concat (file-name-as-directory deft-directory)
				 (format fmt counter))))
	(when deft-filter-regexp
	  (write-region (concat (deft-whole-filter-regexp) "\n\n") nil filename nil))))
    (deft-open-file filename)
    (with-current-buffer (get-file-buffer filename)
      (goto-char (point-max)))))

(defun org-pro-deft-new-project ()
  "Create a new project quickly."
  (interactive)
  (org-pro-new-project (deft-whole-filter-regexp)))

(defun org-pro-deft ()
  (interactive)
  (switch-to-buffer "*deft projects*")
  (deft-mode)
  (deft-local-setup)
  (setq deft-directory org-pro-default-directory)
  (setq deft-find-all-files-function 'org-pro-index-list)
  (setq deft-new-file-function 'org-pro-deft-new-project)
  (setq deft-buffer (current-buffer))
  (deft-local-mode))

#+END_SRC

** Selecting projects
*** Agenda 
#+BEGIN_SRC emacs-lisp :export code
(defun org-pro-project-agenda ()
    "Show an agenda of all the projects. Useful, e.g. for toggling
the active status of projects."
    (interactive)
    (find-file org-pro-file)
    (push ?t unread-command-events)
    (push ?< unread-command-events)
    (call-interactively 'org-agenda))
;;     (defun org-pro-agenda ()
;;      (interactive)
;;      (let ((org-agenda-files
;;             (delq nil (mapcar '(lambda (x) (let ((f (org-pro-get-index x))) (if (file-exists-p f) f))) 
;;                               (org-pro-parse-projects))))
;;            (org-agenda-include-diary nil))
;;            (org-agenda-list)))

#+END_SRC

*** Selecting a project from the project-alist
#+BEGIN_SRC emacs-lisp :export code    
(defun org-pro-format-project (entry)
        (let ((cat (org-pro-get entry "category"))
              (coll (org-pro-get entry "others"))
              (nickname (car entry)))
          (cons
           ;; (format format cat (if coll coll "") nickname)
           (concat cat "/" (if coll (concat coll "/")) (car entry))
           (car entry))))
      
(defun org-pro-select-project ()
        "Select a project from the project alist, 
    which is modified such that 'org-pro-current-project'
    is the first choice."
        (let* ((plist org-pro-project-alist)
               (project-array (mapcar 'org-pro-format-project
                                      (if (not org-pro-current-project)
                                          plist
                                        (setq plist (append (list org-pro-current-project)
                                                (remove org-pro-current-project plist))))))
               (completion-ignore-case t)
               (key (ido-completing-read "Project: " (mapcar 'car project-array)))
               (nickname (cdr (assoc key project-array))))
          (assoc nickname org-pro-project-alist)))
                
#+END_SRC

*** Activating a project

IDEA: let the current project appear in the frame title or in the mode line

See http://www.emacswiki.org/emacs/frame-cmds.el


#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-frame-title-format t
  "If non-nil add the nickname of the active project to frame-title")


(defun org-pro-set-frame-title ()
  (let* ((old-format (split-string frame-title-format "Project:[ \t]+[^ \t]+[ \t]+"))
        (keep (if (> (length old-format) 1) (cadr old-format) (car old-format))))
    (setq frame-title-format
          (concat "Project: " (or (car org-pro-current-project) "No active project") " " keep))))

(defun org-pro-activate-project (project)
  "Sets the current project.
            Start git, if the project is under git control, and git is not up and running yet."
  (setq org-pro-current-project project)
  (if org-pro-frame-title-format
      (org-pro-set-frame-title))
  ;; maybe activate git control
  (when org-pro-use-git 
    (org-pro-git-update-project project 'before)))
#+END_SRC

*** Saving the current project

#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-save-buffers 'save-some-buffers
    "Function to be called to save buffers before switching project.")
(defun org-pro-save-project (&optional project)
    (interactive)
    (when (and (object-p org-pro-save-buffers)
               (functionp org-pro-save-buffers))
      (funcall org-pro-save-buffers))
    (let* ((pro (or project org-pro-current-project)))
       (when org-pro-use-git 
      (org-pro-git-update-project pro nil))))
#+END_SRC    
    
*** Switching between projects

#+BEGIN_SRC emacs-lisp :export code
(defun org-pro-magit (project)
  (magit-status (concat (org-pro-get-location project) (car project))))

(defun org-pro-location (project)
  (find-file (concat (org-pro-get-location project) (car project))))

(defun org-pro-timeline (project)
  (let (tbuf)
    (save-window-excursion
      (let ((index (org-pro-get-index project))
	    (org-agenda-sticky nil))
	(find-file index)
	(org-timeline 'yeah)
	(setq tbuf (current-buffer))))
    (switch-to-buffer tbuf)))

(defun org-pro-recent-org (project)
  (car (org-pro-list-files
	(concat (org-pro-get-location project) (car project)) "^[^\\.].*\\.org$" "time")))

(defun org-pro-todo (project)
  (let (tbuf)
    (save-window-excursion
      (let* ((index (org-pro-get-index project))
	     (location (concat (org-pro-get-location project) (car project)))
	     (org-files (org-pro-list-files location "^[^\\.].*\\.org$" nil))
	     (org-agenda-sticky t) ;; to enable multiple agenda buffers
	     (org-agenda-custom-commands
	      `(("A" "Project agenda"
		 ((todo "TODO"  ((org-agenda-files
				  (append `(,index) org-files)))))))))
	(push ?A unread-command-events)
	(call-interactively 'org-agenda)
	(setq tbuf (current-buffer))))
    (switch-to-buffer tbuf)))

(defun org-pro-find-project (project pos)
  (org-pro-set-config project nil (or pos org-pro-config-cycle-pos 0)))

(defvar org-pro-human-readable-ext "^[^\\.].*\\.org\\|\\.[rR]\\|\\.tex\\|\\.txt\\|\\.el$" "Extensions of human readable files")
(defun org-pro-open-recent (&optional project action)
  (interactive)
  (let* ((pro (or project org-pro-current-project (org-pro-select-project)))
	 (loc (concat (org-pro-get-location pro) (car pro)))
	 (tmplist (if (require 'file-list nil t)
		      (file-list-select-internal nil org-pro-human-readable-ext nil nil loc nil 'dont)))
	 (tmplist2 (when tmplist
		     (file-list-select-internal tmplist "auto" "path" 'inverse nil nil t)))
	 (flist (when tmplist2
		  nil
		  (file-list-sort-internal
		   tmplist2
		   "time" nil t))))
    (when flist
      (when (car flist)
	(find-file (file-list-make-file-name (car flist)))
	(setq flist (cdr flist))
	(org-pro-layout 1)
	(if (car flist)
	    (progn
	      (find-file (file-list-make-file-name (car flist)))
	      (setq flist (cdr flist))
	      (other-window 1))
	  (delete-window))
	(if (car flist)
	    (progn
	      (find-file (file-list-make-file-name (car flist)))
	      (setq flist (cdr flist))
	      (other-window 1))
	  (delete-window))
	(if (car flist)
	    (progn
	      (find-file (file-list-make-file-name (car flist)))
	      (setq flist (cdr flist))
	      (other-window 1))
	  (delete-window))))))
(defun org-pro-get (project el)
  (cdr (assoc el (cadr project))))

(defun org-pro-get-index (project)
  (cdr (assoc "index" (cadr project))))


(defun org-pro-get-git (project)
  (or (cdr (assoc "git" (cadr project))) ""))

(defun org-pro-get-git-location (project)
  (or (cdr (assoc "git-location" (cadr project)))
      (concat (org-pro-get-location project) (car project))))

(defun org-pro-get-location (project)
  "Get the directory associated with PROJECT."
  (file-name-as-directory (cdr (assoc "location" (cadr project)))))
;;  (let ((loc (cdr (assoc "location" (cadr project)))))
;;                (if loc 
;;                                (concat (file-name-as-directory loc)
;;                                        (car project)))))

(defun org-pro-get-publish-directory (project)
  (cdr (assoc "publish-directory" (cadr project))))

(defun org-pro-get-category (project)
  (cdr (assoc "category" (cadr project))))
(defvar org-pro-switch-always t
  "If nil 'org-pro-switch-to-project' will
           switch to current project unless the last command also was 'org-pro-switch-to-project'.
           Setting this variable to non-nil (the default) will force 'org-pro-switch-to-project'
           to always prompt for new project")

(defun org-pro-switch-config (&optional project)
  "Switch to the next window configuration (if any)."
  (interactive)
  (let* ((pro (or project org-pro-current-project))
	 (curpos (or org-pro-config-cycle-pos 0))
	 (config-list (org-pro-read-config-list
		       (or (org-pro-get-config pro) org-pro-config))))
    (if (> (length config-list) (1+ org-pro-config-cycle-pos));; cycle-pos starts at 0
	(setq org-pro-config-cycle-pos (1+ org-pro-config-cycle-pos))
      (setq org-pro-config-cycle-pos 0))
    (org-pro-find-project pro org-pro-config-cycle-pos)))

(defun org-pro-switch (&optional arg)
  "If ARG switch project else switch config."
  (interactive "P")
  (if arg
      (org-pro-switch-to-project)
    (org-pro-switch-config)))

(defun org-pro-switch-to-project (&optional force)
  "Select project via 'org-pro-select-project', activate it
                       via 'org-pro-activate-project',  find the associated index file."
  (interactive "P")
  (let* ((curpro org-pro-current-project)
	 (change-maybe (or force
			   org-pro-switch-always
			   (not org-pro-current-project)))
	 (pro (if change-maybe (org-pro-select-project) curpro))
	 (stay (eq pro curpro)))
    (unless stay
      (org-pro-save-project curpro)
      (setq org-pro-config-cycle-pos 0)
      (org-pro-activate-project pro))
    (org-pro-find-project pro org-pro-config-cycle-pos)))

(defun org-pro-list-files (dir ext sort-by)
  (if (require 'file-list nil t)
      (mapcar 'file-list-make-file-name
	      (file-list-sort-internal
	       (file-list-select-internal nil ext nil nil dir nil 'dont)
	       sort-by nil t))
    (directory-files dir nil ext t)))

(defun org-pro-layout (&optional pos)
  (delete-other-windows)
  (split-window-vertically)
  (split-window-horizontally)
  (other-window -1)
  (split-window-horizontally)
  (other-window 2)
  (other-window (or pos 0)))


(defvar org-pro-human-readable-ext "^[^\\.].*\\.org\\|\\.[rR]\\|\\.tex\\|\\.txt\\|\\.el$" "Extensions of human readable files")
(defun org-pro-open-recent (&optional project action)
  (interactive)
  (let* ((pro (or project org-pro-current-project (org-pro-select-project)))
	 (loc (concat (org-pro-get-location pro) (car pro)))
	 (tmplist (if (require 'file-list nil t)
		      (file-list-select-internal nil org-pro-human-readable-ext nil nil loc nil 'dont)))
	 (tmplist2 (when tmplist
		     (file-list-select-internal tmplist "auto" "path" 'inverse nil nil t)))
	 (flist (when tmplist2
		  nil
		  (file-list-sort-internal
		   tmplist2
		   "time" nil t))))
    (when flist
      (when (car flist)
	(find-file (file-list-make-file-name (car flist)))
	(setq flist (cdr flist))
	(org-pro-layout 1)
	(if (car flist)
	    (progn
	      (find-file (file-list-make-file-name (car flist)))
	      (setq flist (cdr flist))
	      (other-window 1))
	  (delete-window))
	(if (car flist)
	    (progn
	      (find-file (file-list-make-file-name (car flist)))
	      (setq flist (cdr flist))
	      (other-window 1))
	  (delete-window))
	(if (car flist)
	    (progn
	      (find-file (file-list-make-file-name (car flist)))
	      (setq flist (cdr flist))
	      (other-window 1))
	  (delete-window))))))
(defun org-pro-get (project el)
  (cdr (assoc el (cadr project))))

(defun org-pro-get-index (project)
  (cdr (assoc "index" (cadr project))))

(defun org-pro-get-git (project)
  (or (cdr (assoc "git" (cadr project))) ""))

(defun org-pro-get-git-location (project)
  (or (cdr (assoc "git-location" (cadr project)))
      (concat (org-pro-get-location project) (car project))))

(defun org-pro-get-location (project)
  "Get the directory associated with PROJECT."
  (file-name-as-directory (cdr (assoc "location" (cadr project)))))
;;  (let ((loc (cdr (assoc "location" (cadr project)))))
;;                (if loc 
;;                                (concat (file-name-as-directory loc)
;;                                        (car project)))))

(defun org-pro-get-publish-directory (project)
  (cdr (assoc "publish-directory" (cadr project))))

(defun org-pro-get-category (project)
  (cdr (assoc "category" (cadr project))))
#+END_SRC

*** Find specific places in a project
#+BEGIN_SRC emacs-lisp :export code
(defun org-pro-goto-project (&optional project heading create)
    (interactive)
    (let ((pro 
           (or project
              (car (org-pro-select-project)))))
      (when (and (not (string-equal pro "")) pro)
        (let* ((entry (assoc pro org-pro-project-alist))
          (index (org-pro-get-index entry))
          (head (or heading "WorkFlow")))
        (if index
            (find-file index)
          (error (concat "Project " pro " does not have an index.")))
        (goto-char (point-min))
        (or (re-search-forward (concat "^[*]+ " heading) nil t)
            (when create
              (insert "* " heading "\n\n")
              (forward-line  -1)))))))
  
  
(defun org-pro-goto-project-workflow ()
    (interactive)
   (or (org-pro-goto-project nil "WorkFlow" 'create)))
  
  ;; (org-pro-goto-project nil "WorkFlow" t)
  
  
(defun org-pro-goto-project-taskpool (&optional arg)
    (interactive)
    (if arg (org-store-link nil))
    (let* ((buf (current-buffer))
           (pro (completing-read "Select project: " org-pro-project-alist))
           (entry (assoc pro org-pro-project-alist))
           (index (org-pro-get-index entry)))
      (if index
          (find-file index)
        (error (concat "Project " pro " does not have an index.")))
      (goto-char (point-min))
      (or (re-search-forward "^[*]+ TaskPool" nil t)
          (progn
            (goto-char (point-max))
            (insert "\n\n* TaskPool\n")
            (point)))))
#+END_SRC     

** Export
*** Publishing

#+BEGIN_SRC emacs-lisp :export code
(defvar org-pro-export-subdirectory "export")
(defvar org-pro-public-directory "~/public_html/")
;; (defvar org-pro-publish-subdirectory "public")
(require 'org-publish)
(defun org-pro-set-publish-alist ()
  (interactive)
  (let ((p-alist org-pro-project-alist))
    (while p-alist
      (let* ((pro  (car p-alist))
	     (nickname (car pro))
	     (base-directory (concat (org-pro-get-location pro) (car pro)))
	     (export-directory
	      (concat base-directory "/"
		      org-pro-export-subdirectory))
	     (public-directory
	      (or (org-pro-get-publish-directory pro)
		  (concat (file-name-as-directory org-pro-public-directory)
			  nickname))))
	;;(replace-regexp-in-string org-pro-public-directory (getenv "HOME") (expand-file-name export-directory))))
	(add-to-list 'org-publish-project-alist
		     `(,(concat nickname "-export")
		       :base-directory
		       ,base-directory
		       :base-extension "org"
		       :publishing-directory
		       ,base-directory
		       :headline-levels 4
		       :auto-preamble t
		       :recursive t
		       :publishing-function
		       org-publish-org-to-html))
	(add-to-list 'org-publish-project-alist
		     `(,(concat nickname "-copy")
		       :base-directory
		       ,export-directory
		       :base-extension
		       "html\\|png\\|jpg\\|org\\|pdf"
		       :publishing-directory
		       ,public-directory
		       :recursive t
		       :publishing-function
		       org-publish-attachment))
	(add-to-list 'org-publish-project-alist
		     `(,nickname
		       :components (,(concat nickname "-export") ,(concat nickname "-copy")))))
      (setq p-alist (cdr p-alist)))))
#+END_SRC   

** The end
#+BEGIN_SRC emacs-lisp :export code
(provide 'org-project-manager)
#+END_SRC
